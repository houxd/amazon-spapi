/*
 * Selling Partner API for Messaging
 *
 * With the Messaging API you can build applications that send messages to buyers. You can get a list of message types that are available for an order that you specify, then call an operation that sends a message to the buyer for that order. The Messaging API returns responses that are formed according to the <a href=https://tools.ietf.org/html/draft-kelly-json-hal-08>JSON Hypertext Application Language</a> (HAL) standard.
 *
 * The version of the OpenAPI document: v1
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`confirm_customization_details`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfirmCustomizationDetailsError {
    Status400(models::messaging::CreateConfirmCustomizationDetailsResponse),
    Status403(models::messaging::CreateConfirmCustomizationDetailsResponse),
    Status404(models::messaging::CreateConfirmCustomizationDetailsResponse),
    Status413(models::messaging::CreateConfirmCustomizationDetailsResponse),
    Status415(models::messaging::CreateConfirmCustomizationDetailsResponse),
    Status429(models::messaging::CreateConfirmCustomizationDetailsResponse),
    Status500(models::messaging::CreateConfirmCustomizationDetailsResponse),
    Status503(models::messaging::CreateConfirmCustomizationDetailsResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_amazon_motors`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAmazonMotorsError {
    Status400(models::messaging::CreateAmazonMotorsResponse),
    Status403(models::messaging::CreateAmazonMotorsResponse),
    Status404(models::messaging::CreateAmazonMotorsResponse),
    Status413(models::messaging::CreateAmazonMotorsResponse),
    Status415(models::messaging::CreateAmazonMotorsResponse),
    Status429(models::messaging::CreateAmazonMotorsResponse),
    Status500(models::messaging::CreateAmazonMotorsResponse),
    Status503(models::messaging::CreateAmazonMotorsResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_confirm_delivery_details`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateConfirmDeliveryDetailsError {
    Status400(models::messaging::CreateConfirmDeliveryDetailsResponse),
    Status403(models::messaging::CreateConfirmDeliveryDetailsResponse),
    Status404(models::messaging::CreateConfirmDeliveryDetailsResponse),
    Status413(models::messaging::CreateConfirmDeliveryDetailsResponse),
    Status415(models::messaging::CreateConfirmDeliveryDetailsResponse),
    Status429(models::messaging::CreateConfirmDeliveryDetailsResponse),
    Status500(models::messaging::CreateConfirmDeliveryDetailsResponse),
    Status503(models::messaging::CreateConfirmDeliveryDetailsResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_confirm_order_details`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateConfirmOrderDetailsError {
    Status400(models::messaging::CreateConfirmOrderDetailsResponse),
    Status403(models::messaging::CreateConfirmOrderDetailsResponse),
    Status404(models::messaging::CreateConfirmOrderDetailsResponse),
    Status413(models::messaging::CreateConfirmOrderDetailsResponse),
    Status415(models::messaging::CreateConfirmOrderDetailsResponse),
    Status429(models::messaging::CreateConfirmOrderDetailsResponse),
    Status500(models::messaging::CreateConfirmOrderDetailsResponse),
    Status503(models::messaging::CreateConfirmOrderDetailsResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_confirm_service_details`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateConfirmServiceDetailsError {
    Status400(models::messaging::CreateConfirmServiceDetailsResponse),
    Status403(models::messaging::CreateConfirmServiceDetailsResponse),
    Status404(models::messaging::CreateConfirmServiceDetailsResponse),
    Status413(models::messaging::CreateConfirmServiceDetailsResponse),
    Status415(models::messaging::CreateConfirmServiceDetailsResponse),
    Status429(models::messaging::CreateConfirmServiceDetailsResponse),
    Status500(models::messaging::CreateConfirmServiceDetailsResponse),
    Status503(models::messaging::CreateConfirmServiceDetailsResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_digital_access_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDigitalAccessKeyError {
    Status400(models::messaging::CreateDigitalAccessKeyResponse),
    Status403(models::messaging::CreateDigitalAccessKeyResponse),
    Status404(models::messaging::CreateDigitalAccessKeyResponse),
    Status413(models::messaging::CreateDigitalAccessKeyResponse),
    Status415(models::messaging::CreateDigitalAccessKeyResponse),
    Status429(models::messaging::CreateDigitalAccessKeyResponse),
    Status500(models::messaging::CreateDigitalAccessKeyResponse),
    Status503(models::messaging::CreateDigitalAccessKeyResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_legal_disclosure`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateLegalDisclosureError {
    Status400(models::messaging::CreateLegalDisclosureResponse),
    Status403(models::messaging::CreateLegalDisclosureResponse),
    Status404(models::messaging::CreateLegalDisclosureResponse),
    Status413(models::messaging::CreateLegalDisclosureResponse),
    Status415(models::messaging::CreateLegalDisclosureResponse),
    Status429(models::messaging::CreateLegalDisclosureResponse),
    Status500(models::messaging::CreateLegalDisclosureResponse),
    Status503(models::messaging::CreateLegalDisclosureResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_negative_feedback_removal`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateNegativeFeedbackRemovalError {
    Status400(models::messaging::CreateNegativeFeedbackRemovalResponse),
    Status403(models::messaging::CreateNegativeFeedbackRemovalResponse),
    Status404(models::messaging::CreateNegativeFeedbackRemovalResponse),
    Status413(models::messaging::CreateNegativeFeedbackRemovalResponse),
    Status415(models::messaging::CreateNegativeFeedbackRemovalResponse),
    Status429(models::messaging::CreateNegativeFeedbackRemovalResponse),
    Status500(models::messaging::CreateNegativeFeedbackRemovalResponse),
    Status503(models::messaging::CreateNegativeFeedbackRemovalResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_unexpected_problem`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateUnexpectedProblemError {
    Status400(models::messaging::CreateUnexpectedProblemResponse),
    Status403(models::messaging::CreateUnexpectedProblemResponse),
    Status404(models::messaging::CreateUnexpectedProblemResponse),
    Status413(models::messaging::CreateUnexpectedProblemResponse),
    Status415(models::messaging::CreateUnexpectedProblemResponse),
    Status429(models::messaging::CreateUnexpectedProblemResponse),
    Status500(models::messaging::CreateUnexpectedProblemResponse),
    Status503(models::messaging::CreateUnexpectedProblemResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_warranty`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateWarrantyError {
    Status400(models::messaging::CreateWarrantyResponse),
    Status403(models::messaging::CreateWarrantyResponse),
    Status404(models::messaging::CreateWarrantyResponse),
    Status413(models::messaging::CreateWarrantyResponse),
    Status415(models::messaging::CreateWarrantyResponse),
    Status429(models::messaging::CreateWarrantyResponse),
    Status500(models::messaging::CreateWarrantyResponse),
    Status503(models::messaging::CreateWarrantyResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_attributes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAttributesError {
    Status400(models::messaging::GetAttributesResponse),
    Status403(models::messaging::GetAttributesResponse),
    Status404(models::messaging::GetAttributesResponse),
    Status413(models::messaging::GetAttributesResponse),
    Status415(models::messaging::GetAttributesResponse),
    Status429(models::messaging::GetAttributesResponse),
    Status500(models::messaging::GetAttributesResponse),
    Status503(models::messaging::GetAttributesResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_messaging_actions_for_order`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMessagingActionsForOrderError {
    Status400(models::messaging::GetMessagingActionsForOrderResponse),
    Status403(models::messaging::GetMessagingActionsForOrderResponse),
    Status404(models::messaging::GetMessagingActionsForOrderResponse),
    Status413(models::messaging::GetMessagingActionsForOrderResponse),
    Status415(models::messaging::GetMessagingActionsForOrderResponse),
    Status429(models::messaging::GetMessagingActionsForOrderResponse),
    Status500(models::messaging::GetMessagingActionsForOrderResponse),
    Status503(models::messaging::GetMessagingActionsForOrderResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`send_invoice`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SendInvoiceError {
    Status400(models::messaging::InvoiceResponse),
    Status403(models::messaging::InvoiceResponse),
    Status404(models::messaging::InvoiceResponse),
    Status413(models::messaging::InvoiceResponse),
    Status415(models::messaging::InvoiceResponse),
    Status429(models::messaging::InvoiceResponse),
    Status500(models::messaging::InvoiceResponse),
    Status503(models::messaging::InvoiceResponse),
    UnknownValue(serde_json::Value),
}


/// Sends a message asking a buyer to provide or verify customization details such as name spelling, images, initials, etc.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 1 | 5 |  The `x-amzn-RateLimit-Limit` response header contains the usage plan rate limits for the operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput might have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn confirm_customization_details(configuration: &configuration::Configuration, amazon_order_id: &str, marketplace_ids: Vec<String>, body: models::messaging::CreateConfirmCustomizationDetailsRequest) -> Result<models::messaging::CreateConfirmCustomizationDetailsResponse, Error<ConfirmCustomizationDetailsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_amazon_order_id = amazon_order_id;
    let p_marketplace_ids = marketplace_ids;
    let p_body = body;

    let uri_str = format!("{}/messaging/v1/orders/{amazonOrderId}/messages/confirmCustomizationDetails", configuration.base_path, amazonOrderId=crate::apis::urlencode(p_amazon_order_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = match "csv" {
        "multi" => req_builder.query(&p_marketplace_ids.into_iter().map(|p| ("marketplaceIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("marketplaceIds", &p_marketplace_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::messaging::CreateConfirmCustomizationDetailsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::messaging::CreateConfirmCustomizationDetailsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfirmCustomizationDetailsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sends a message to a buyer to provide details about an Amazon Motors order. This message can only be sent by Amazon Motors sellers.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 1 | 5 |  The `x-amzn-RateLimit-Limit` response header contains the usage plan rate limits for the operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput might have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn create_amazon_motors(configuration: &configuration::Configuration, amazon_order_id: &str, marketplace_ids: Vec<String>, body: models::messaging::CreateAmazonMotorsRequest) -> Result<models::messaging::CreateAmazonMotorsResponse, Error<CreateAmazonMotorsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_amazon_order_id = amazon_order_id;
    let p_marketplace_ids = marketplace_ids;
    let p_body = body;

    let uri_str = format!("{}/messaging/v1/orders/{amazonOrderId}/messages/amazonMotors", configuration.base_path, amazonOrderId=crate::apis::urlencode(p_amazon_order_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = match "csv" {
        "multi" => req_builder.query(&p_marketplace_ids.into_iter().map(|p| ("marketplaceIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("marketplaceIds", &p_marketplace_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::messaging::CreateAmazonMotorsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::messaging::CreateAmazonMotorsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateAmazonMotorsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sends a message to a buyer to arrange a delivery or to confirm contact information for making a delivery.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 1 | 5 |  The `x-amzn-RateLimit-Limit` response header contains the usage plan rate limits for the operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput might have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn create_confirm_delivery_details(configuration: &configuration::Configuration, amazon_order_id: &str, marketplace_ids: Vec<String>, body: models::messaging::CreateConfirmDeliveryDetailsRequest) -> Result<models::messaging::CreateConfirmDeliveryDetailsResponse, Error<CreateConfirmDeliveryDetailsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_amazon_order_id = amazon_order_id;
    let p_marketplace_ids = marketplace_ids;
    let p_body = body;

    let uri_str = format!("{}/messaging/v1/orders/{amazonOrderId}/messages/confirmDeliveryDetails", configuration.base_path, amazonOrderId=crate::apis::urlencode(p_amazon_order_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = match "csv" {
        "multi" => req_builder.query(&p_marketplace_ids.into_iter().map(|p| ("marketplaceIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("marketplaceIds", &p_marketplace_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::messaging::CreateConfirmDeliveryDetailsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::messaging::CreateConfirmDeliveryDetailsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateConfirmDeliveryDetailsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sends a message to ask a buyer an order-related question prior to shipping their order.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 1 | 5 |  The `x-amzn-RateLimit-Limit` response header contains the usage plan rate limits for the operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput might have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn create_confirm_order_details(configuration: &configuration::Configuration, amazon_order_id: &str, marketplace_ids: Vec<String>, body: models::messaging::CreateConfirmOrderDetailsRequest) -> Result<models::messaging::CreateConfirmOrderDetailsResponse, Error<CreateConfirmOrderDetailsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_amazon_order_id = amazon_order_id;
    let p_marketplace_ids = marketplace_ids;
    let p_body = body;

    let uri_str = format!("{}/messaging/v1/orders/{amazonOrderId}/messages/confirmOrderDetails", configuration.base_path, amazonOrderId=crate::apis::urlencode(p_amazon_order_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = match "csv" {
        "multi" => req_builder.query(&p_marketplace_ids.into_iter().map(|p| ("marketplaceIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("marketplaceIds", &p_marketplace_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::messaging::CreateConfirmOrderDetailsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::messaging::CreateConfirmOrderDetailsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateConfirmOrderDetailsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sends a message to contact a Home Service customer to arrange a service call or to gather information prior to a service call.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 1 | 5 |  The `x-amzn-RateLimit-Limit` response header contains the usage plan rate limits for the operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput might have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn create_confirm_service_details(configuration: &configuration::Configuration, amazon_order_id: &str, marketplace_ids: Vec<String>, body: models::messaging::CreateConfirmServiceDetailsRequest) -> Result<models::messaging::CreateConfirmServiceDetailsResponse, Error<CreateConfirmServiceDetailsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_amazon_order_id = amazon_order_id;
    let p_marketplace_ids = marketplace_ids;
    let p_body = body;

    let uri_str = format!("{}/messaging/v1/orders/{amazonOrderId}/messages/confirmServiceDetails", configuration.base_path, amazonOrderId=crate::apis::urlencode(p_amazon_order_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = match "csv" {
        "multi" => req_builder.query(&p_marketplace_ids.into_iter().map(|p| ("marketplaceIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("marketplaceIds", &p_marketplace_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::messaging::CreateConfirmServiceDetailsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::messaging::CreateConfirmServiceDetailsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateConfirmServiceDetailsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sends a buyer a message to share a digital access key that is required to utilize digital content in their order.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 1 | 5 |  The `x-amzn-RateLimit-Limit` response header contains the usage plan rate limits for the operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput might have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn create_digital_access_key(configuration: &configuration::Configuration, amazon_order_id: &str, marketplace_ids: Vec<String>, body: models::messaging::CreateDigitalAccessKeyRequest) -> Result<models::messaging::CreateDigitalAccessKeyResponse, Error<CreateDigitalAccessKeyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_amazon_order_id = amazon_order_id;
    let p_marketplace_ids = marketplace_ids;
    let p_body = body;

    let uri_str = format!("{}/messaging/v1/orders/{amazonOrderId}/messages/digitalAccessKey", configuration.base_path, amazonOrderId=crate::apis::urlencode(p_amazon_order_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = match "csv" {
        "multi" => req_builder.query(&p_marketplace_ids.into_iter().map(|p| ("marketplaceIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("marketplaceIds", &p_marketplace_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::messaging::CreateDigitalAccessKeyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::messaging::CreateDigitalAccessKeyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateDigitalAccessKeyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sends a critical message that contains documents that a seller is legally obligated to provide to the buyer. This message should only be used to deliver documents that are required by law.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 1 | 5 |  The `x-amzn-RateLimit-Limit` response header contains the usage plan rate limits for the operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput might have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn create_legal_disclosure(configuration: &configuration::Configuration, amazon_order_id: &str, marketplace_ids: Vec<String>, body: models::messaging::CreateLegalDisclosureRequest) -> Result<models::messaging::CreateLegalDisclosureResponse, Error<CreateLegalDisclosureError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_amazon_order_id = amazon_order_id;
    let p_marketplace_ids = marketplace_ids;
    let p_body = body;

    let uri_str = format!("{}/messaging/v1/orders/{amazonOrderId}/messages/legalDisclosure", configuration.base_path, amazonOrderId=crate::apis::urlencode(p_amazon_order_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = match "csv" {
        "multi" => req_builder.query(&p_marketplace_ids.into_iter().map(|p| ("marketplaceIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("marketplaceIds", &p_marketplace_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::messaging::CreateLegalDisclosureResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::messaging::CreateLegalDisclosureResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateLegalDisclosureError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sends a non-critical message that asks a buyer to remove their negative feedback. This message should only be sent after the seller has resolved the buyer's problem.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 1 | 5 |  The `x-amzn-RateLimit-Limit` response header contains the usage plan rate limits for the operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput might have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn create_negative_feedback_removal(configuration: &configuration::Configuration, amazon_order_id: &str, marketplace_ids: Vec<String>) -> Result<models::messaging::CreateNegativeFeedbackRemovalResponse, Error<CreateNegativeFeedbackRemovalError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_amazon_order_id = amazon_order_id;
    let p_marketplace_ids = marketplace_ids;

    let uri_str = format!("{}/messaging/v1/orders/{amazonOrderId}/messages/negativeFeedbackRemoval", configuration.base_path, amazonOrderId=crate::apis::urlencode(p_amazon_order_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = match "csv" {
        "multi" => req_builder.query(&p_marketplace_ids.into_iter().map(|p| ("marketplaceIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("marketplaceIds", &p_marketplace_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::messaging::CreateNegativeFeedbackRemovalResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::messaging::CreateNegativeFeedbackRemovalResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateNegativeFeedbackRemovalError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sends a critical message to a buyer that an unexpected problem was encountered affecting the completion of the order.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 1 | 5 |  The `x-amzn-RateLimit-Limit` response header contains the usage plan rate limits for the operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput might have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn create_unexpected_problem(configuration: &configuration::Configuration, amazon_order_id: &str, marketplace_ids: Vec<String>, body: models::messaging::CreateUnexpectedProblemRequest) -> Result<models::messaging::CreateUnexpectedProblemResponse, Error<CreateUnexpectedProblemError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_amazon_order_id = amazon_order_id;
    let p_marketplace_ids = marketplace_ids;
    let p_body = body;

    let uri_str = format!("{}/messaging/v1/orders/{amazonOrderId}/messages/unexpectedProblem", configuration.base_path, amazonOrderId=crate::apis::urlencode(p_amazon_order_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = match "csv" {
        "multi" => req_builder.query(&p_marketplace_ids.into_iter().map(|p| ("marketplaceIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("marketplaceIds", &p_marketplace_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::messaging::CreateUnexpectedProblemResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::messaging::CreateUnexpectedProblemResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateUnexpectedProblemError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sends a message to a buyer to provide details about warranty information on a purchase in their order.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 1 | 5 |  The `x-amzn-RateLimit-Limit` response header contains the usage plan rate limits for the operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput might have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn create_warranty(configuration: &configuration::Configuration, amazon_order_id: &str, marketplace_ids: Vec<String>, body: models::messaging::CreateWarrantyRequest) -> Result<models::messaging::CreateWarrantyResponse, Error<CreateWarrantyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_amazon_order_id = amazon_order_id;
    let p_marketplace_ids = marketplace_ids;
    let p_body = body;

    let uri_str = format!("{}/messaging/v1/orders/{amazonOrderId}/messages/warranty", configuration.base_path, amazonOrderId=crate::apis::urlencode(p_amazon_order_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = match "csv" {
        "multi" => req_builder.query(&p_marketplace_ids.into_iter().map(|p| ("marketplaceIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("marketplaceIds", &p_marketplace_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::messaging::CreateWarrantyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::messaging::CreateWarrantyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateWarrantyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a response containing attributes related to an order. This includes buyer preferences.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 1 | 5 |
pub async fn get_attributes(configuration: &configuration::Configuration, amazon_order_id: &str, marketplace_ids: Vec<String>) -> Result<models::messaging::GetAttributesResponse, Error<GetAttributesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_amazon_order_id = amazon_order_id;
    let p_marketplace_ids = marketplace_ids;

    let uri_str = format!("{}/messaging/v1/orders/{amazonOrderId}/attributes", configuration.base_path, amazonOrderId=crate::apis::urlencode(p_amazon_order_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = match "csv" {
        "multi" => req_builder.query(&p_marketplace_ids.into_iter().map(|p| ("marketplaceIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("marketplaceIds", &p_marketplace_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::messaging::GetAttributesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::messaging::GetAttributesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAttributesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a list of message types that are available for an order that you specify. A message type is represented by an actions object, which contains a path and query parameter(s). You can use the path and parameter(s) to call an operation that sends a message.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 1 | 5 |  The `x-amzn-RateLimit-Limit` response header contains the usage plan rate limits for the operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput might have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn get_messaging_actions_for_order(configuration: &configuration::Configuration, amazon_order_id: &str, marketplace_ids: Vec<String>) -> Result<models::messaging::GetMessagingActionsForOrderResponse, Error<GetMessagingActionsForOrderError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_amazon_order_id = amazon_order_id;
    let p_marketplace_ids = marketplace_ids;

    let uri_str = format!("{}/messaging/v1/orders/{amazonOrderId}", configuration.base_path, amazonOrderId=crate::apis::urlencode(p_amazon_order_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = match "csv" {
        "multi" => req_builder.query(&p_marketplace_ids.into_iter().map(|p| ("marketplaceIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("marketplaceIds", &p_marketplace_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::messaging::GetMessagingActionsForOrderResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::messaging::GetMessagingActionsForOrderResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMessagingActionsForOrderError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sends a message providing the buyer an invoice
pub async fn send_invoice(configuration: &configuration::Configuration, amazon_order_id: &str, marketplace_ids: Vec<String>, body: models::messaging::InvoiceRequest) -> Result<models::messaging::InvoiceResponse, Error<SendInvoiceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_amazon_order_id = amazon_order_id;
    let p_marketplace_ids = marketplace_ids;
    let p_body = body;

    let uri_str = format!("{}/messaging/v1/orders/{amazonOrderId}/messages/invoice", configuration.base_path, amazonOrderId=crate::apis::urlencode(p_amazon_order_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = match "csv" {
        "multi" => req_builder.query(&p_marketplace_ids.into_iter().map(|p| ("marketplaceIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("marketplaceIds", &p_marketplace_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::messaging::InvoiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::messaging::InvoiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SendInvoiceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

