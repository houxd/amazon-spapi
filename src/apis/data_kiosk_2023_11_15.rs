/*
 * Selling Partner API for Data Kiosk
 *
 * The Selling Partner API for Data Kiosk lets you submit GraphQL queries from a variety of schemas to help selling partners manage their businesses.
 *
 * The version of the OpenAPI document: 2023-11-15
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`cancel_query`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CancelQueryError {
    Status400(models::data_kiosk_2023_11_15::ErrorList),
    Status403(models::data_kiosk_2023_11_15::ErrorList),
    Status404(models::data_kiosk_2023_11_15::ErrorList),
    Status413(models::data_kiosk_2023_11_15::ErrorList),
    Status415(models::data_kiosk_2023_11_15::ErrorList),
    Status429(models::data_kiosk_2023_11_15::ErrorList),
    Status500(models::data_kiosk_2023_11_15::ErrorList),
    Status503(models::data_kiosk_2023_11_15::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_query`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateQueryError {
    Status400(models::data_kiosk_2023_11_15::ErrorList),
    Status403(models::data_kiosk_2023_11_15::ErrorList),
    Status404(models::data_kiosk_2023_11_15::ErrorList),
    Status413(models::data_kiosk_2023_11_15::ErrorList),
    Status415(models::data_kiosk_2023_11_15::ErrorList),
    Status429(models::data_kiosk_2023_11_15::ErrorList),
    Status500(models::data_kiosk_2023_11_15::ErrorList),
    Status503(models::data_kiosk_2023_11_15::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDocumentError {
    Status400(models::data_kiosk_2023_11_15::ErrorList),
    Status403(models::data_kiosk_2023_11_15::ErrorList),
    Status404(models::data_kiosk_2023_11_15::ErrorList),
    Status413(models::data_kiosk_2023_11_15::ErrorList),
    Status415(models::data_kiosk_2023_11_15::ErrorList),
    Status429(models::data_kiosk_2023_11_15::ErrorList),
    Status500(models::data_kiosk_2023_11_15::ErrorList),
    Status503(models::data_kiosk_2023_11_15::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_queries`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetQueriesError {
    Status400(models::data_kiosk_2023_11_15::ErrorList),
    Status403(models::data_kiosk_2023_11_15::ErrorList),
    Status404(models::data_kiosk_2023_11_15::ErrorList),
    Status413(models::data_kiosk_2023_11_15::ErrorList),
    Status415(models::data_kiosk_2023_11_15::ErrorList),
    Status429(models::data_kiosk_2023_11_15::ErrorList),
    Status500(models::data_kiosk_2023_11_15::ErrorList),
    Status503(models::data_kiosk_2023_11_15::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_query`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetQueryError {
    Status400(models::data_kiosk_2023_11_15::ErrorList),
    Status403(models::data_kiosk_2023_11_15::ErrorList),
    Status404(models::data_kiosk_2023_11_15::ErrorList),
    Status413(models::data_kiosk_2023_11_15::ErrorList),
    Status415(models::data_kiosk_2023_11_15::ErrorList),
    Status429(models::data_kiosk_2023_11_15::ErrorList),
    Status500(models::data_kiosk_2023_11_15::ErrorList),
    Status503(models::data_kiosk_2023_11_15::ErrorList),
    UnknownValue(serde_json::Value),
}


/// Cancels the query specified by the `queryId` parameter. Only queries with a non-terminal `processingStatus` (`IN_QUEUE`, `IN_PROGRESS`) can be cancelled. Cancelling a query that already has a `processingStatus` of `CANCELLED` will no-op. Cancelled queries are returned in subsequent calls to the `getQuery` and `getQueries` operations.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 0.0222 | 10 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn cancel_query(configuration: &configuration::Configuration, query_id: &str) -> Result<(), Error<CancelQueryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_id = query_id;

    let uri_str = format!("{}/dataKiosk/2023-11-15/queries/{queryId}", configuration.base_path, queryId=crate::apis::urlencode(p_query_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CancelQueryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a Data Kiosk query request.  **Note:** The retention of a query varies based on the fields requested. Each field within a schema is annotated with a `@resultRetention` directive that defines how long a query containing that field will be retained. When a query contains multiple fields with different retentions, the shortest (minimum) retention is applied. The retention of a query's resulting documents always matches the retention of the query.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 0.0167 | 15 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn create_query(configuration: &configuration::Configuration, body: models::data_kiosk_2023_11_15::CreateQuerySpecification) -> Result<models::data_kiosk_2023_11_15::CreateQueryResponse, Error<CreateQueryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body = body;

    let uri_str = format!("{}/dataKiosk/2023-11-15/queries", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::data_kiosk_2023_11_15::CreateQueryResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::data_kiosk_2023_11_15::CreateQueryResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateQueryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the information required for retrieving a Data Kiosk document's contents. See the `createQuery` operation for details about document retention.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 0.0167 | 15 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn get_document(configuration: &configuration::Configuration, document_id: &str) -> Result<models::data_kiosk_2023_11_15::GetDocumentResponse, Error<GetDocumentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_document_id = document_id;

    let uri_str = format!("{}/dataKiosk/2023-11-15/documents/{documentId}", configuration.base_path, documentId=crate::apis::urlencode(p_document_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::data_kiosk_2023_11_15::GetDocumentResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::data_kiosk_2023_11_15::GetDocumentResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDocumentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns details for the Data Kiosk queries that match the specified filters. See the `createQuery` operation for details about query retention.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 0.0222 | 10 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn get_queries(configuration: &configuration::Configuration, processing_statuses: Option<Vec<String>>, page_size: Option<i32>, created_since: Option<String>, created_until: Option<String>, pagination_token: Option<&str>) -> Result<models::data_kiosk_2023_11_15::GetQueriesResponse, Error<GetQueriesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_processing_statuses = processing_statuses;
    let p_page_size = page_size;
    let p_created_since = created_since;
    let p_created_until = created_until;
    let p_pagination_token = pagination_token;

    let uri_str = format!("{}/dataKiosk/2023-11-15/queries", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_processing_statuses {
        req_builder = match "csv" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("processingStatuses".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("processingStatuses", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("pageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_created_since {
        req_builder = req_builder.query(&[("createdSince", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_created_until {
        req_builder = req_builder.query(&[("createdUntil", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_pagination_token {
        req_builder = req_builder.query(&[("paginationToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::data_kiosk_2023_11_15::GetQueriesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::data_kiosk_2023_11_15::GetQueriesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetQueriesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns query details for the query specified by the `queryId` parameter. See the `createQuery` operation for details about query retention.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2.0 | 15 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn get_query(configuration: &configuration::Configuration, query_id: &str) -> Result<models::data_kiosk_2023_11_15::Query, Error<GetQueryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_id = query_id;

    let uri_str = format!("{}/dataKiosk/2023-11-15/queries/{queryId}", configuration.base_path, queryId=crate::apis::urlencode(p_query_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::data_kiosk_2023_11_15::Query`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::data_kiosk_2023_11_15::Query`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetQueryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

