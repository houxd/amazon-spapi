/*
 * Selling Partner API for Orders
 *
 * Use the Orders Selling Partner API to programmatically retrieve order information. With this API, you can develop fast, flexible, and custom applications to manage order synchronization, perform order research, and create demand-based decision support tools.   _Note:_ For the JP, AU, and SG marketplaces, the Orders API supports orders from 2016 onward. For all other marketplaces, the Orders API supports orders for the last two years (orders older than this don't show up in the response).
 *
 * The version of the OpenAPI document: v0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`confirm_shipment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfirmShipmentError {
    Status400(models::orders_v0::ConfirmShipmentErrorResponse),
    Status401(models::orders_v0::ConfirmShipmentErrorResponse),
    Status403(models::orders_v0::ConfirmShipmentErrorResponse),
    Status404(models::orders_v0::ConfirmShipmentErrorResponse),
    Status429(models::orders_v0::ConfirmShipmentErrorResponse),
    Status500(models::orders_v0::ConfirmShipmentErrorResponse),
    Status503(models::orders_v0::ConfirmShipmentErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_order`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOrderError {
    Status400(models::orders_v0::GetOrderResponse),
    Status403(models::orders_v0::GetOrderResponse),
    Status404(models::orders_v0::GetOrderResponse),
    Status429(models::orders_v0::GetOrderResponse),
    Status500(models::orders_v0::GetOrderResponse),
    Status503(models::orders_v0::GetOrderResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_order_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOrderAddressError {
    Status400(models::orders_v0::GetOrderAddressResponse),
    Status403(models::orders_v0::GetOrderAddressResponse),
    Status404(models::orders_v0::GetOrderAddressResponse),
    Status429(models::orders_v0::GetOrderAddressResponse),
    Status500(models::orders_v0::GetOrderAddressResponse),
    Status503(models::orders_v0::GetOrderAddressResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_order_buyer_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOrderBuyerInfoError {
    Status400(models::orders_v0::GetOrderBuyerInfoResponse),
    Status403(models::orders_v0::GetOrderBuyerInfoResponse),
    Status404(models::orders_v0::GetOrderBuyerInfoResponse),
    Status429(models::orders_v0::GetOrderBuyerInfoResponse),
    Status500(models::orders_v0::GetOrderBuyerInfoResponse),
    Status503(models::orders_v0::GetOrderBuyerInfoResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_order_items`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOrderItemsError {
    Status400(models::orders_v0::GetOrderItemsResponse),
    Status403(models::orders_v0::GetOrderItemsResponse),
    Status404(models::orders_v0::GetOrderItemsResponse),
    Status429(models::orders_v0::GetOrderItemsResponse),
    Status500(models::orders_v0::GetOrderItemsResponse),
    Status503(models::orders_v0::GetOrderItemsResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_order_items_buyer_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOrderItemsBuyerInfoError {
    Status400(models::orders_v0::GetOrderItemsBuyerInfoResponse),
    Status403(models::orders_v0::GetOrderItemsBuyerInfoResponse),
    Status404(models::orders_v0::GetOrderItemsBuyerInfoResponse),
    Status429(models::orders_v0::GetOrderItemsBuyerInfoResponse),
    Status500(models::orders_v0::GetOrderItemsBuyerInfoResponse),
    Status503(models::orders_v0::GetOrderItemsBuyerInfoResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_order_regulated_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOrderRegulatedInfoError {
    Status400(models::orders_v0::GetOrderRegulatedInfoResponse),
    Status403(models::orders_v0::GetOrderRegulatedInfoResponse),
    Status404(models::orders_v0::GetOrderRegulatedInfoResponse),
    Status429(models::orders_v0::GetOrderRegulatedInfoResponse),
    Status500(models::orders_v0::GetOrderRegulatedInfoResponse),
    Status503(models::orders_v0::GetOrderRegulatedInfoResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_orders`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOrdersError {
    Status400(models::orders_v0::GetOrdersResponse),
    Status403(models::orders_v0::GetOrdersResponse),
    Status404(models::orders_v0::GetOrdersResponse),
    Status429(models::orders_v0::GetOrdersResponse),
    Status500(models::orders_v0::GetOrdersResponse),
    Status503(models::orders_v0::GetOrdersResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_verification_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateVerificationStatusError {
    Status400(models::orders_v0::UpdateVerificationStatusErrorResponse),
    Status403(models::orders_v0::UpdateVerificationStatusErrorResponse),
    Status404(models::orders_v0::UpdateVerificationStatusErrorResponse),
    Status413(models::orders_v0::UpdateVerificationStatusErrorResponse),
    Status415(models::orders_v0::UpdateVerificationStatusErrorResponse),
    Status429(models::orders_v0::UpdateVerificationStatusErrorResponse),
    Status500(models::orders_v0::UpdateVerificationStatusErrorResponse),
    Status503(models::orders_v0::UpdateVerificationStatusErrorResponse),
    UnknownValue(serde_json::Value),
}


/// Updates the shipment confirmation status for a specified order.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 10 |  The `x-amzn-RateLimit-Limit` response header contains the usage plan rate limits for the operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput might have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn confirm_shipment(configuration: &configuration::Configuration, order_id: &str, payload: models::orders_v0::ConfirmShipmentRequest) -> Result<(), Error<ConfirmShipmentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_order_id = order_id;
    let p_payload = payload;

    let uri_str = format!("{}/orders/v0/orders/{orderId}/shipmentConfirmation", configuration.base_path, orderId=crate::apis::urlencode(p_order_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_payload);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfirmShipmentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the order that you specify.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 0.5 | 30 |  The `x-amzn-RateLimit-Limit` response header contains the usage plan rate limits for the operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput might have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn get_order(configuration: &configuration::Configuration, order_id: &str) -> Result<models::orders_v0::GetOrderResponse, Error<GetOrderError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_order_id = order_id;

    let uri_str = format!("{}/orders/v0/orders/{orderId}", configuration.base_path, orderId=crate::apis::urlencode(p_order_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::orders_v0::GetOrderResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::orders_v0::GetOrderResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetOrderError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the shipping address for the order that you specify.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 0.5 | 30 |  The `x-amzn-RateLimit-Limit` response header contains the usage plan rate limits for the operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput might have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn get_order_address(configuration: &configuration::Configuration, order_id: &str) -> Result<models::orders_v0::GetOrderAddressResponse, Error<GetOrderAddressError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_order_id = order_id;

    let uri_str = format!("{}/orders/v0/orders/{orderId}/address", configuration.base_path, orderId=crate::apis::urlencode(p_order_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::orders_v0::GetOrderAddressResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::orders_v0::GetOrderAddressResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetOrderAddressError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns buyer information for the order that you specify.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 0.5 | 30 |  The `x-amzn-RateLimit-Limit` response header contains the usage plan rate limits for the operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput might have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn get_order_buyer_info(configuration: &configuration::Configuration, order_id: &str) -> Result<models::orders_v0::GetOrderBuyerInfoResponse, Error<GetOrderBuyerInfoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_order_id = order_id;

    let uri_str = format!("{}/orders/v0/orders/{orderId}/buyerInfo", configuration.base_path, orderId=crate::apis::urlencode(p_order_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::orders_v0::GetOrderBuyerInfoResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::orders_v0::GetOrderBuyerInfoResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetOrderBuyerInfoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns detailed order item information for the order that you specify. If `NextToken` is provided, it's used to retrieve the next page of order items.  __Note__: When an order is in the Pending state (the order has been placed but payment has not been authorized), the getOrderItems operation does not return information about pricing, taxes, shipping charges, gift status or promotions for the order items in the order. After an order leaves the Pending state (this occurs when payment has been authorized) and enters the Unshipped, Partially Shipped, or Shipped state, the getOrderItems operation returns information about pricing, taxes, shipping charges, gift status and promotions for the order items in the order.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 0.5 | 30 |  The `x-amzn-RateLimit-Limit` response header contains the usage plan rate limits for the operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput might have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn get_order_items(configuration: &configuration::Configuration, order_id: &str, next_token: Option<&str>) -> Result<models::orders_v0::GetOrderItemsResponse, Error<GetOrderItemsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_order_id = order_id;
    let p_next_token = next_token;

    let uri_str = format!("{}/orders/v0/orders/{orderId}/orderItems", configuration.base_path, orderId=crate::apis::urlencode(p_order_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_next_token {
        req_builder = req_builder.query(&[("NextToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::orders_v0::GetOrderItemsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::orders_v0::GetOrderItemsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetOrderItemsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns buyer information for the order items in the order that you specify.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 0.5 | 30 |  The `x-amzn-RateLimit-Limit` response header contains the usage plan rate limits for the operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput might have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn get_order_items_buyer_info(configuration: &configuration::Configuration, order_id: &str, next_token: Option<&str>) -> Result<models::orders_v0::GetOrderItemsBuyerInfoResponse, Error<GetOrderItemsBuyerInfoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_order_id = order_id;
    let p_next_token = next_token;

    let uri_str = format!("{}/orders/v0/orders/{orderId}/orderItems/buyerInfo", configuration.base_path, orderId=crate::apis::urlencode(p_order_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_next_token {
        req_builder = req_builder.query(&[("NextToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::orders_v0::GetOrderItemsBuyerInfoResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::orders_v0::GetOrderItemsBuyerInfoResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetOrderItemsBuyerInfoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns regulated information for the order that you specify.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 0.5 | 30 |  The `x-amzn-RateLimit-Limit` response header contains the usage plan rate limits for the operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput might have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn get_order_regulated_info(configuration: &configuration::Configuration, order_id: &str) -> Result<models::orders_v0::GetOrderRegulatedInfoResponse, Error<GetOrderRegulatedInfoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_order_id = order_id;

    let uri_str = format!("{}/orders/v0/orders/{orderId}/regulatedInfo", configuration.base_path, orderId=crate::apis::urlencode(p_order_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::orders_v0::GetOrderRegulatedInfoResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::orders_v0::GetOrderRegulatedInfoResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetOrderRegulatedInfoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns orders that are created or updated during the specified time period. If you want to return specific types of orders, you can apply filters to your request. `NextToken` doesn't affect any filters that you include in your request; it only impacts the pagination for the filtered orders response.   **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 0.0167 | 20 |  The `x-amzn-RateLimit-Limit` response header contains the usage plan rate limits for the operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput might have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn get_orders(configuration: &configuration::Configuration, marketplace_ids: Vec<String>, created_after: Option<&str>, created_before: Option<&str>, last_updated_after: Option<&str>, last_updated_before: Option<&str>, order_statuses: Option<Vec<String>>, fulfillment_channels: Option<Vec<String>>, payment_methods: Option<Vec<String>>, buyer_email: Option<&str>, seller_order_id: Option<&str>, max_results_per_page: Option<i32>, easy_ship_shipment_statuses: Option<Vec<String>>, electronic_invoice_statuses: Option<Vec<String>>, next_token: Option<&str>, amazon_order_ids: Option<Vec<String>>, actual_fulfillment_supply_source_id: Option<&str>, is_ispu: Option<bool>, store_chain_store_id: Option<&str>, earliest_delivery_date_before: Option<&str>, earliest_delivery_date_after: Option<&str>, latest_delivery_date_before: Option<&str>, latest_delivery_date_after: Option<&str>) -> Result<models::orders_v0::GetOrdersResponse, Error<GetOrdersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_marketplace_ids = marketplace_ids;
    let p_created_after = created_after;
    let p_created_before = created_before;
    let p_last_updated_after = last_updated_after;
    let p_last_updated_before = last_updated_before;
    let p_order_statuses = order_statuses;
    let p_fulfillment_channels = fulfillment_channels;
    let p_payment_methods = payment_methods;
    let p_buyer_email = buyer_email;
    let p_seller_order_id = seller_order_id;
    let p_max_results_per_page = max_results_per_page;
    let p_easy_ship_shipment_statuses = easy_ship_shipment_statuses;
    let p_electronic_invoice_statuses = electronic_invoice_statuses;
    let p_next_token = next_token;
    let p_amazon_order_ids = amazon_order_ids;
    let p_actual_fulfillment_supply_source_id = actual_fulfillment_supply_source_id;
    let p_is_ispu = is_ispu;
    let p_store_chain_store_id = store_chain_store_id;
    let p_earliest_delivery_date_before = earliest_delivery_date_before;
    let p_earliest_delivery_date_after = earliest_delivery_date_after;
    let p_latest_delivery_date_before = latest_delivery_date_before;
    let p_latest_delivery_date_after = latest_delivery_date_after;

    let uri_str = format!("{}/orders/v0/orders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_created_after {
        req_builder = req_builder.query(&[("CreatedAfter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_created_before {
        req_builder = req_builder.query(&[("CreatedBefore", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_last_updated_after {
        req_builder = req_builder.query(&[("LastUpdatedAfter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_last_updated_before {
        req_builder = req_builder.query(&[("LastUpdatedBefore", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_order_statuses {
        req_builder = match "csv" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("OrderStatuses".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("OrderStatuses", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    req_builder = match "csv" {
        "multi" => req_builder.query(&p_marketplace_ids.into_iter().map(|p| ("MarketplaceIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("MarketplaceIds", &p_marketplace_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref param_value) = p_fulfillment_channels {
        req_builder = match "csv" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("FulfillmentChannels".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("FulfillmentChannels", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_payment_methods {
        req_builder = match "csv" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("PaymentMethods".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("PaymentMethods", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_buyer_email {
        req_builder = req_builder.query(&[("BuyerEmail", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_seller_order_id {
        req_builder = req_builder.query(&[("SellerOrderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_max_results_per_page {
        req_builder = req_builder.query(&[("MaxResultsPerPage", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_easy_ship_shipment_statuses {
        req_builder = match "csv" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("EasyShipShipmentStatuses".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("EasyShipShipmentStatuses", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_electronic_invoice_statuses {
        req_builder = match "csv" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("ElectronicInvoiceStatuses".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("ElectronicInvoiceStatuses", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_next_token {
        req_builder = req_builder.query(&[("NextToken", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_amazon_order_ids {
        req_builder = match "csv" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("AmazonOrderIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("AmazonOrderIds", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_actual_fulfillment_supply_source_id {
        req_builder = req_builder.query(&[("ActualFulfillmentSupplySourceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_is_ispu {
        req_builder = req_builder.query(&[("IsISPU", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_store_chain_store_id {
        req_builder = req_builder.query(&[("StoreChainStoreId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_earliest_delivery_date_before {
        req_builder = req_builder.query(&[("EarliestDeliveryDateBefore", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_earliest_delivery_date_after {
        req_builder = req_builder.query(&[("EarliestDeliveryDateAfter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_latest_delivery_date_before {
        req_builder = req_builder.query(&[("LatestDeliveryDateBefore", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_latest_delivery_date_after {
        req_builder = req_builder.query(&[("LatestDeliveryDateAfter", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::orders_v0::GetOrdersResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::orders_v0::GetOrdersResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetOrdersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates (approves or rejects) the verification status of an order containing regulated products.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 0.5 | 30 |  The `x-amzn-RateLimit-Limit` response header contains the usage plan rate limits for the operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput might have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn update_verification_status(configuration: &configuration::Configuration, order_id: &str, payload: models::orders_v0::UpdateVerificationStatusRequest) -> Result<(), Error<UpdateVerificationStatusError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_order_id = order_id;
    let p_payload = payload;

    let uri_str = format!("{}/orders/v0/orders/{orderId}/regulatedInfo", configuration.base_path, orderId=crate::apis::urlencode(p_order_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_payload);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateVerificationStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

