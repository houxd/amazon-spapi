/*
 * Selling Partner API for A+ Content Management
 *
 * Use the A+ Content API to build applications that help selling partners add rich marketing content to their Amazon product detail pages. Selling partners can use A+ content to share their brand and product story, which helps buyers make informed purchasing decisions. Selling partners use content modules to add images and text.
 *
 * The version of the OpenAPI document: 2020-11-01
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`create_content_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateContentDocumentError {
    Status400(models::aplus_content_2020_11_01::ErrorList),
    Status401(models::aplus_content_2020_11_01::ErrorList),
    Status403(models::aplus_content_2020_11_01::ErrorList),
    Status404(models::aplus_content_2020_11_01::ErrorList),
    Status429(models::aplus_content_2020_11_01::ErrorList),
    Status500(models::aplus_content_2020_11_01::ErrorList),
    Status503(models::aplus_content_2020_11_01::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_content_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetContentDocumentError {
    Status400(models::aplus_content_2020_11_01::ErrorList),
    Status401(models::aplus_content_2020_11_01::ErrorList),
    Status403(models::aplus_content_2020_11_01::ErrorList),
    Status404(models::aplus_content_2020_11_01::ErrorList),
    Status410(models::aplus_content_2020_11_01::ErrorList),
    Status429(models::aplus_content_2020_11_01::ErrorList),
    Status500(models::aplus_content_2020_11_01::ErrorList),
    Status503(models::aplus_content_2020_11_01::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_content_document_asin_relations`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListContentDocumentAsinRelationsError {
    Status400(models::aplus_content_2020_11_01::ErrorList),
    Status401(models::aplus_content_2020_11_01::ErrorList),
    Status403(models::aplus_content_2020_11_01::ErrorList),
    Status404(models::aplus_content_2020_11_01::ErrorList),
    Status410(models::aplus_content_2020_11_01::ErrorList),
    Status429(models::aplus_content_2020_11_01::ErrorList),
    Status500(models::aplus_content_2020_11_01::ErrorList),
    Status503(models::aplus_content_2020_11_01::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_content_document_approval_submission`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostContentDocumentApprovalSubmissionError {
    Status400(models::aplus_content_2020_11_01::ErrorList),
    Status401(models::aplus_content_2020_11_01::ErrorList),
    Status403(models::aplus_content_2020_11_01::ErrorList),
    Status404(models::aplus_content_2020_11_01::ErrorList),
    Status410(models::aplus_content_2020_11_01::ErrorList),
    Status429(models::aplus_content_2020_11_01::ErrorList),
    Status500(models::aplus_content_2020_11_01::ErrorList),
    Status503(models::aplus_content_2020_11_01::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_content_document_asin_relations`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostContentDocumentAsinRelationsError {
    Status400(models::aplus_content_2020_11_01::ErrorList),
    Status401(models::aplus_content_2020_11_01::ErrorList),
    Status403(models::aplus_content_2020_11_01::ErrorList),
    Status404(models::aplus_content_2020_11_01::ErrorList),
    Status410(models::aplus_content_2020_11_01::ErrorList),
    Status429(models::aplus_content_2020_11_01::ErrorList),
    Status500(models::aplus_content_2020_11_01::ErrorList),
    Status503(models::aplus_content_2020_11_01::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_content_document_suspend_submission`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostContentDocumentSuspendSubmissionError {
    Status400(models::aplus_content_2020_11_01::ErrorList),
    Status401(models::aplus_content_2020_11_01::ErrorList),
    Status403(models::aplus_content_2020_11_01::ErrorList),
    Status404(models::aplus_content_2020_11_01::ErrorList),
    Status410(models::aplus_content_2020_11_01::ErrorList),
    Status429(models::aplus_content_2020_11_01::ErrorList),
    Status500(models::aplus_content_2020_11_01::ErrorList),
    Status503(models::aplus_content_2020_11_01::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_content_documents`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchContentDocumentsError {
    Status400(models::aplus_content_2020_11_01::ErrorList),
    Status401(models::aplus_content_2020_11_01::ErrorList),
    Status403(models::aplus_content_2020_11_01::ErrorList),
    Status404(models::aplus_content_2020_11_01::ErrorList),
    Status410(models::aplus_content_2020_11_01::ErrorList),
    Status429(models::aplus_content_2020_11_01::ErrorList),
    Status500(models::aplus_content_2020_11_01::ErrorList),
    Status503(models::aplus_content_2020_11_01::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_content_publish_records`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchContentPublishRecordsError {
    Status400(models::aplus_content_2020_11_01::ErrorList),
    Status401(models::aplus_content_2020_11_01::ErrorList),
    Status403(models::aplus_content_2020_11_01::ErrorList),
    Status404(models::aplus_content_2020_11_01::ErrorList),
    Status429(models::aplus_content_2020_11_01::ErrorList),
    Status500(models::aplus_content_2020_11_01::ErrorList),
    Status503(models::aplus_content_2020_11_01::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_content_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateContentDocumentError {
    Status400(models::aplus_content_2020_11_01::ErrorList),
    Status401(models::aplus_content_2020_11_01::ErrorList),
    Status403(models::aplus_content_2020_11_01::ErrorList),
    Status404(models::aplus_content_2020_11_01::ErrorList),
    Status410(models::aplus_content_2020_11_01::ErrorList),
    Status429(models::aplus_content_2020_11_01::ErrorList),
    Status500(models::aplus_content_2020_11_01::ErrorList),
    Status503(models::aplus_content_2020_11_01::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`validate_content_document_asin_relations`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ValidateContentDocumentAsinRelationsError {
    Status400(models::aplus_content_2020_11_01::ErrorList),
    Status401(models::aplus_content_2020_11_01::ErrorList),
    Status403(models::aplus_content_2020_11_01::ErrorList),
    Status404(models::aplus_content_2020_11_01::ErrorList),
    Status429(models::aplus_content_2020_11_01::ErrorList),
    Status500(models::aplus_content_2020_11_01::ErrorList),
    Status503(models::aplus_content_2020_11_01::ErrorList),
    UnknownValue(serde_json::Value),
}


/// Creates a new A+ Content document.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 10 | 10 |  The `x-amzn-RateLimit-Limit` response header contains the usage plan rate limits for the operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput might have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn create_content_document(configuration: &configuration::Configuration, marketplace_id: &str, post_content_document_request: models::aplus_content_2020_11_01::PostContentDocumentRequest) -> Result<models::aplus_content_2020_11_01::PostContentDocumentResponse, Error<CreateContentDocumentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_marketplace_id = marketplace_id;
    let p_post_content_document_request = post_content_document_request;

    let uri_str = format!("{}/aplus/2020-11-01/contentDocuments", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("marketplaceId", &p_marketplace_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_post_content_document_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::aplus_content_2020_11_01::PostContentDocumentResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::aplus_content_2020_11_01::PostContentDocumentResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateContentDocumentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns an A+ Content document, if available.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 10 | 10 |  The `x-amzn-RateLimit-Limit` response header contains the usage plan rate limits for the operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput might have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn get_content_document(configuration: &configuration::Configuration, content_reference_key: &str, marketplace_id: &str, included_data_set: Vec<String>) -> Result<models::aplus_content_2020_11_01::GetContentDocumentResponse, Error<GetContentDocumentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_content_reference_key = content_reference_key;
    let p_marketplace_id = marketplace_id;
    let p_included_data_set = included_data_set;

    let uri_str = format!("{}/aplus/2020-11-01/contentDocuments/{contentReferenceKey}", configuration.base_path, contentReferenceKey=crate::apis::urlencode(p_content_reference_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("marketplaceId", &p_marketplace_id.to_string())]);
    req_builder = match "csv" {
        "multi" => req_builder.query(&p_included_data_set.into_iter().map(|p| ("includedDataSet".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("includedDataSet", &p_included_data_set.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::aplus_content_2020_11_01::GetContentDocumentResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::aplus_content_2020_11_01::GetContentDocumentResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetContentDocumentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a list of ASINs that are related to the specified A+ Content document, if available. If you don't include the `asinSet` parameter, this operation returns all ASINs related to the content document.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 10 | 10 |  The `x-amzn-RateLimit-Limit` response header contains the usage plan rate limits for the operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput might have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn list_content_document_asin_relations(configuration: &configuration::Configuration, content_reference_key: &str, marketplace_id: &str, included_data_set: Option<Vec<String>>, asin_set: Option<Vec<String>>, page_token: Option<&str>) -> Result<models::aplus_content_2020_11_01::ListContentDocumentAsinRelationsResponse, Error<ListContentDocumentAsinRelationsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_content_reference_key = content_reference_key;
    let p_marketplace_id = marketplace_id;
    let p_included_data_set = included_data_set;
    let p_asin_set = asin_set;
    let p_page_token = page_token;

    let uri_str = format!("{}/aplus/2020-11-01/contentDocuments/{contentReferenceKey}/asins", configuration.base_path, contentReferenceKey=crate::apis::urlencode(p_content_reference_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("marketplaceId", &p_marketplace_id.to_string())]);
    if let Some(ref param_value) = p_included_data_set {
        req_builder = match "csv" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("includedDataSet".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("includedDataSet", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_asin_set {
        req_builder = match "csv" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("asinSet".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("asinSet", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_page_token {
        req_builder = req_builder.query(&[("pageToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::aplus_content_2020_11_01::ListContentDocumentAsinRelationsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::aplus_content_2020_11_01::ListContentDocumentAsinRelationsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListContentDocumentAsinRelationsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Submits an A+ Content document for review, approval, and publishing.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 10 | 10 |  The `x-amzn-RateLimit-Limit` response header contains the usage plan rate limits for the operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput might have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn post_content_document_approval_submission(configuration: &configuration::Configuration, content_reference_key: &str, marketplace_id: &str) -> Result<models::aplus_content_2020_11_01::PostContentDocumentApprovalSubmissionResponse, Error<PostContentDocumentApprovalSubmissionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_content_reference_key = content_reference_key;
    let p_marketplace_id = marketplace_id;

    let uri_str = format!("{}/aplus/2020-11-01/contentDocuments/{contentReferenceKey}/approvalSubmissions", configuration.base_path, contentReferenceKey=crate::apis::urlencode(p_content_reference_key));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("marketplaceId", &p_marketplace_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::aplus_content_2020_11_01::PostContentDocumentApprovalSubmissionResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::aplus_content_2020_11_01::PostContentDocumentApprovalSubmissionResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostContentDocumentApprovalSubmissionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Replaces all ASINs related to the specified A+ Content document, if available. This operation can add or remove ASINs, depending on the current set of related ASINs. Removing an ASIN will suspend the content document from that ASIN.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 10 | 10 |  The `x-amzn-RateLimit-Limit` response header contains the usage plan rate limits for the operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput might have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn post_content_document_asin_relations(configuration: &configuration::Configuration, content_reference_key: &str, marketplace_id: &str, post_content_document_asin_relations_request: models::aplus_content_2020_11_01::PostContentDocumentAsinRelationsRequest) -> Result<models::aplus_content_2020_11_01::PostContentDocumentAsinRelationsResponse, Error<PostContentDocumentAsinRelationsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_content_reference_key = content_reference_key;
    let p_marketplace_id = marketplace_id;
    let p_post_content_document_asin_relations_request = post_content_document_asin_relations_request;

    let uri_str = format!("{}/aplus/2020-11-01/contentDocuments/{contentReferenceKey}/asins", configuration.base_path, contentReferenceKey=crate::apis::urlencode(p_content_reference_key));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("marketplaceId", &p_marketplace_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_post_content_document_asin_relations_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::aplus_content_2020_11_01::PostContentDocumentAsinRelationsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::aplus_content_2020_11_01::PostContentDocumentAsinRelationsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostContentDocumentAsinRelationsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Submits a request to suspend visible A+ Content. This doesn't delete the content document or the ASIN relations.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 10 | 10 |  The `x-amzn-RateLimit-Limit` response header contains the usage plan rate limits for the operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput might have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn post_content_document_suspend_submission(configuration: &configuration::Configuration, content_reference_key: &str, marketplace_id: &str) -> Result<models::aplus_content_2020_11_01::PostContentDocumentSuspendSubmissionResponse, Error<PostContentDocumentSuspendSubmissionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_content_reference_key = content_reference_key;
    let p_marketplace_id = marketplace_id;

    let uri_str = format!("{}/aplus/2020-11-01/contentDocuments/{contentReferenceKey}/suspendSubmissions", configuration.base_path, contentReferenceKey=crate::apis::urlencode(p_content_reference_key));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("marketplaceId", &p_marketplace_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::aplus_content_2020_11_01::PostContentDocumentSuspendSubmissionResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::aplus_content_2020_11_01::PostContentDocumentSuspendSubmissionResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostContentDocumentSuspendSubmissionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a list of all A+ Content documents, including metadata, that are assigned to a selling partner. To get the actual contents of the A+ Content documents, call the `getContentDocument` operation.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 10 | 10 |  The `x-amzn-RateLimit-Limit` response header contains the usage plan rate limits for the operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput might have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn search_content_documents(configuration: &configuration::Configuration, marketplace_id: &str, page_token: Option<&str>) -> Result<models::aplus_content_2020_11_01::SearchContentDocumentsResponse, Error<SearchContentDocumentsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_marketplace_id = marketplace_id;
    let p_page_token = page_token;

    let uri_str = format!("{}/aplus/2020-11-01/contentDocuments", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("marketplaceId", &p_marketplace_id.to_string())]);
    if let Some(ref param_value) = p_page_token {
        req_builder = req_builder.query(&[("pageToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::aplus_content_2020_11_01::SearchContentDocumentsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::aplus_content_2020_11_01::SearchContentDocumentsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchContentDocumentsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Searches for A+ Content publishing records, if available.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 10 | 10 |  The `x-amzn-RateLimit-Limit` response header contains the usage plan rate limits for the operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput might have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn search_content_publish_records(configuration: &configuration::Configuration, marketplace_id: &str, asin: &str, page_token: Option<&str>) -> Result<models::aplus_content_2020_11_01::SearchContentPublishRecordsResponse, Error<SearchContentPublishRecordsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_marketplace_id = marketplace_id;
    let p_asin = asin;
    let p_page_token = page_token;

    let uri_str = format!("{}/aplus/2020-11-01/contentPublishRecords", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("marketplaceId", &p_marketplace_id.to_string())]);
    req_builder = req_builder.query(&[("asin", &p_asin.to_string())]);
    if let Some(ref param_value) = p_page_token {
        req_builder = req_builder.query(&[("pageToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::aplus_content_2020_11_01::SearchContentPublishRecordsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::aplus_content_2020_11_01::SearchContentPublishRecordsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchContentPublishRecordsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates an existing A+ Content document.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 10 | 10 |  The `x-amzn-RateLimit-Limit` response header contains the usage plan rate limits for the operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput might have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn update_content_document(configuration: &configuration::Configuration, content_reference_key: &str, marketplace_id: &str, post_content_document_request: models::aplus_content_2020_11_01::PostContentDocumentRequest) -> Result<models::aplus_content_2020_11_01::PostContentDocumentResponse, Error<UpdateContentDocumentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_content_reference_key = content_reference_key;
    let p_marketplace_id = marketplace_id;
    let p_post_content_document_request = post_content_document_request;

    let uri_str = format!("{}/aplus/2020-11-01/contentDocuments/{contentReferenceKey}", configuration.base_path, contentReferenceKey=crate::apis::urlencode(p_content_reference_key));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("marketplaceId", &p_marketplace_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_post_content_document_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::aplus_content_2020_11_01::PostContentDocumentResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::aplus_content_2020_11_01::PostContentDocumentResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateContentDocumentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Checks if the A+ Content document is valid for use on a set of ASINs.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 10 | 10 |  The `x-amzn-RateLimit-Limit` response header contains the usage plan rate limits for the operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput might have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn validate_content_document_asin_relations(configuration: &configuration::Configuration, marketplace_id: &str, post_content_document_request: models::aplus_content_2020_11_01::PostContentDocumentRequest, asin_set: Option<Vec<String>>) -> Result<models::aplus_content_2020_11_01::ValidateContentDocumentAsinRelationsResponse, Error<ValidateContentDocumentAsinRelationsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_marketplace_id = marketplace_id;
    let p_post_content_document_request = post_content_document_request;
    let p_asin_set = asin_set;

    let uri_str = format!("{}/aplus/2020-11-01/contentAsinValidations", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("marketplaceId", &p_marketplace_id.to_string())]);
    if let Some(ref param_value) = p_asin_set {
        req_builder = match "csv" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("asinSet".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("asinSet", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_post_content_document_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::aplus_content_2020_11_01::ValidateContentDocumentAsinRelationsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::aplus_content_2020_11_01::ValidateContentDocumentAsinRelationsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ValidateContentDocumentAsinRelationsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

