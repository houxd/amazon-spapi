/*
 * Selling Partner API for Services
 *
 * With the Services API, you can build applications that help service providers get and modify their service orders and manage their resources.
 *
 * The version of the OpenAPI document: v1
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`add_appointment_for_service_job_by_service_job_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddAppointmentForServiceJobByServiceJobIdError {
    Status400(models::services::SetAppointmentResponse),
    Status403(models::services::SetAppointmentResponse),
    Status404(models::services::SetAppointmentResponse),
    Status413(models::services::SetAppointmentResponse),
    Status415(models::services::SetAppointmentResponse),
    Status422(models::services::SetAppointmentResponse),
    Status429(models::services::SetAppointmentResponse),
    Status500(models::services::SetAppointmentResponse),
    Status503(models::services::SetAppointmentResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`assign_appointment_resources`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AssignAppointmentResourcesError {
    Status400(models::services::AssignAppointmentResourcesResponse),
    Status403(models::services::AssignAppointmentResourcesResponse),
    Status404(models::services::AssignAppointmentResourcesResponse),
    Status413(models::services::AssignAppointmentResourcesResponse),
    Status415(models::services::AssignAppointmentResourcesResponse),
    Status422(models::services::AssignAppointmentResourcesResponse),
    Status429(models::services::AssignAppointmentResourcesResponse),
    Status500(models::services::AssignAppointmentResourcesResponse),
    Status503(models::services::AssignAppointmentResourcesResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cancel_reservation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CancelReservationError {
    Status400(models::services::CancelReservationResponse),
    Status403(models::services::CancelReservationResponse),
    Status404(models::services::CancelReservationResponse),
    Status413(models::services::CancelReservationResponse),
    Status415(models::services::CancelReservationResponse),
    Status429(models::services::CancelReservationResponse),
    Status500(models::services::CancelReservationResponse),
    Status503(models::services::CancelReservationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cancel_service_job_by_service_job_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CancelServiceJobByServiceJobIdError {
    Status400(models::services::CancelServiceJobByServiceJobIdResponse),
    Status403(models::services::CancelServiceJobByServiceJobIdResponse),
    Status404(models::services::CancelServiceJobByServiceJobIdResponse),
    Status413(models::services::CancelServiceJobByServiceJobIdResponse),
    Status415(models::services::CancelServiceJobByServiceJobIdResponse),
    Status422(models::services::CancelServiceJobByServiceJobIdResponse),
    Status429(models::services::CancelServiceJobByServiceJobIdResponse),
    Status500(models::services::CancelServiceJobByServiceJobIdResponse),
    Status503(models::services::CancelServiceJobByServiceJobIdResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`complete_service_job_by_service_job_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CompleteServiceJobByServiceJobIdError {
    Status400(models::services::CompleteServiceJobByServiceJobIdResponse),
    Status403(models::services::CompleteServiceJobByServiceJobIdResponse),
    Status404(models::services::CompleteServiceJobByServiceJobIdResponse),
    Status413(models::services::CompleteServiceJobByServiceJobIdResponse),
    Status415(models::services::CompleteServiceJobByServiceJobIdResponse),
    Status422(models::services::CompleteServiceJobByServiceJobIdResponse),
    Status429(models::services::CompleteServiceJobByServiceJobIdResponse),
    Status500(models::services::CompleteServiceJobByServiceJobIdResponse),
    Status503(models::services::CompleteServiceJobByServiceJobIdResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_reservation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateReservationError {
    Status400(models::services::CreateReservationResponse),
    Status403(models::services::CreateReservationResponse),
    Status404(models::services::CreateReservationResponse),
    Status413(models::services::CreateReservationResponse),
    Status415(models::services::CreateReservationResponse),
    Status429(models::services::CreateReservationResponse),
    Status500(models::services::CreateReservationResponse),
    Status503(models::services::CreateReservationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_service_document_upload_destination`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateServiceDocumentUploadDestinationError {
    Status400(models::services::CreateServiceDocumentUploadDestination),
    Status403(models::services::CreateServiceDocumentUploadDestination),
    Status404(models::services::CreateServiceDocumentUploadDestination),
    Status413(models::services::CreateServiceDocumentUploadDestination),
    Status415(models::services::CreateServiceDocumentUploadDestination),
    Status422(models::services::CreateServiceDocumentUploadDestination),
    Status429(models::services::CreateServiceDocumentUploadDestination),
    Status500(models::services::CreateServiceDocumentUploadDestination),
    Status503(models::services::CreateServiceDocumentUploadDestination),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_appointment_slots`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAppointmentSlotsError {
    Status400(models::services::GetAppointmentSlotsResponse),
    Status403(models::services::GetAppointmentSlotsResponse),
    Status404(models::services::GetAppointmentSlotsResponse),
    Status415(models::services::GetAppointmentSlotsResponse),
    Status422(models::services::GetAppointmentSlotsResponse),
    Status429(models::services::GetAppointmentSlotsResponse),
    Status500(models::services::GetAppointmentSlotsResponse),
    Status503(models::services::GetAppointmentSlotsResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_appointmment_slots_by_job_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAppointmmentSlotsByJobIdError {
    Status400(models::services::GetAppointmentSlotsResponse),
    Status403(models::services::GetAppointmentSlotsResponse),
    Status404(models::services::GetAppointmentSlotsResponse),
    Status415(models::services::GetAppointmentSlotsResponse),
    Status422(models::services::GetAppointmentSlotsResponse),
    Status429(models::services::GetAppointmentSlotsResponse),
    Status500(models::services::GetAppointmentSlotsResponse),
    Status503(models::services::GetAppointmentSlotsResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_fixed_slot_capacity`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFixedSlotCapacityError {
    Status400(models::services::FixedSlotCapacityErrors),
    Status401(models::services::FixedSlotCapacityErrors),
    Status403(models::services::FixedSlotCapacityErrors),
    Status404(models::services::FixedSlotCapacityErrors),
    Status413(models::services::FixedSlotCapacityErrors),
    Status415(models::services::FixedSlotCapacityErrors),
    Status429(models::services::FixedSlotCapacityErrors),
    Status500(models::services::FixedSlotCapacityErrors),
    Status503(models::services::FixedSlotCapacityErrors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_range_slot_capacity`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRangeSlotCapacityError {
    Status400(models::services::RangeSlotCapacityErrors),
    Status401(models::services::RangeSlotCapacityErrors),
    Status403(models::services::RangeSlotCapacityErrors),
    Status404(models::services::RangeSlotCapacityErrors),
    Status413(models::services::RangeSlotCapacityErrors),
    Status415(models::services::RangeSlotCapacityErrors),
    Status429(models::services::RangeSlotCapacityErrors),
    Status500(models::services::RangeSlotCapacityErrors),
    Status503(models::services::RangeSlotCapacityErrors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_service_job_by_service_job_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetServiceJobByServiceJobIdError {
    Status400(models::services::GetServiceJobByServiceJobIdResponse),
    Status403(models::services::GetServiceJobByServiceJobIdResponse),
    Status404(models::services::GetServiceJobByServiceJobIdResponse),
    Status413(models::services::GetServiceJobByServiceJobIdResponse),
    Status415(models::services::GetServiceJobByServiceJobIdResponse),
    Status422(models::services::GetServiceJobByServiceJobIdResponse),
    Status429(models::services::GetServiceJobByServiceJobIdResponse),
    Status500(models::services::GetServiceJobByServiceJobIdResponse),
    Status503(models::services::GetServiceJobByServiceJobIdResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_service_jobs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetServiceJobsError {
    Status400(models::services::GetServiceJobsResponse),
    Status403(models::services::GetServiceJobsResponse),
    Status404(models::services::GetServiceJobsResponse),
    Status413(models::services::GetServiceJobsResponse),
    Status415(models::services::GetServiceJobsResponse),
    Status429(models::services::GetServiceJobsResponse),
    Status500(models::services::GetServiceJobsResponse),
    Status503(models::services::GetServiceJobsResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reschedule_appointment_for_service_job_by_service_job_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RescheduleAppointmentForServiceJobByServiceJobIdError {
    Status400(models::services::SetAppointmentResponse),
    Status403(models::services::SetAppointmentResponse),
    Status404(models::services::SetAppointmentResponse),
    Status413(models::services::SetAppointmentResponse),
    Status415(models::services::SetAppointmentResponse),
    Status422(models::services::SetAppointmentResponse),
    Status429(models::services::SetAppointmentResponse),
    Status500(models::services::SetAppointmentResponse),
    Status503(models::services::SetAppointmentResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_appointment_fulfillment_data`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetAppointmentFulfillmentDataError {
    Status400(Vec<models::services::Error>),
    Status403(Vec<models::services::Error>),
    Status404(Vec<models::services::Error>),
    Status413(Vec<models::services::Error>),
    Status415(Vec<models::services::Error>),
    Status422(Vec<models::services::Error>),
    Status429(Vec<models::services::Error>),
    Status500(Vec<models::services::Error>),
    Status503(Vec<models::services::Error>),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_reservation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateReservationError {
    Status400(models::services::UpdateReservationResponse),
    Status403(models::services::UpdateReservationResponse),
    Status404(models::services::UpdateReservationResponse),
    Status413(models::services::UpdateReservationResponse),
    Status415(models::services::UpdateReservationResponse),
    Status429(models::services::UpdateReservationResponse),
    Status500(models::services::UpdateReservationResponse),
    Status503(models::services::UpdateReservationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_schedule`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateScheduleError {
    Status400(models::services::UpdateScheduleResponse),
    Status403(models::services::UpdateScheduleResponse),
    Status404(models::services::UpdateScheduleResponse),
    Status413(models::services::UpdateScheduleResponse),
    Status415(models::services::UpdateScheduleResponse),
    Status429(models::services::UpdateScheduleResponse),
    Status500(models::services::UpdateScheduleResponse),
    Status503(models::services::UpdateScheduleResponse),
    UnknownValue(serde_json::Value),
}


/// Adds an appointment to the service job indicated by the service job identifier specified.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).
pub async fn add_appointment_for_service_job_by_service_job_id(configuration: &configuration::Configuration, service_job_id: &str, body: models::services::AddAppointmentRequest) -> Result<models::services::SetAppointmentResponse, Error<AddAppointmentForServiceJobByServiceJobIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_service_job_id = service_job_id;
    let p_body = body;

    let uri_str = format!("{}/service/v1/serviceJobs/{serviceJobId}/appointments", configuration.base_path, serviceJobId=crate::apis::urlencode(p_service_job_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::services::SetAppointmentResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::services::SetAppointmentResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddAppointmentForServiceJobByServiceJobIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Assigns new resource(s) or overwrite/update the existing one(s) to a service job appointment.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 1 | 2 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).
pub async fn assign_appointment_resources(configuration: &configuration::Configuration, service_job_id: &str, appointment_id: &str, body: models::services::AssignAppointmentResourcesRequest) -> Result<models::services::AssignAppointmentResourcesResponse, Error<AssignAppointmentResourcesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_service_job_id = service_job_id;
    let p_appointment_id = appointment_id;
    let p_body = body;

    let uri_str = format!("{}/service/v1/serviceJobs/{serviceJobId}/appointments/{appointmentId}/resources", configuration.base_path, serviceJobId=crate::apis::urlencode(p_service_job_id), appointmentId=crate::apis::urlencode(p_appointment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::services::AssignAppointmentResourcesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::services::AssignAppointmentResourcesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AssignAppointmentResourcesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancel a reservation.   **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).
pub async fn cancel_reservation(configuration: &configuration::Configuration, reservation_id: &str, marketplace_ids: Vec<String>) -> Result<models::services::CancelReservationResponse, Error<CancelReservationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_reservation_id = reservation_id;
    let p_marketplace_ids = marketplace_ids;

    let uri_str = format!("{}/service/v1/reservation/{reservationId}", configuration.base_path, reservationId=crate::apis::urlencode(p_reservation_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = match "csv" {
        "multi" => req_builder.query(&p_marketplace_ids.into_iter().map(|p| ("marketplaceIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("marketplaceIds", &p_marketplace_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::services::CancelReservationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::services::CancelReservationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CancelReservationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancels the service job indicated by the service job identifier specified.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).
pub async fn cancel_service_job_by_service_job_id(configuration: &configuration::Configuration, service_job_id: &str, cancellation_reason_code: &str) -> Result<models::services::CancelServiceJobByServiceJobIdResponse, Error<CancelServiceJobByServiceJobIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_service_job_id = service_job_id;
    let p_cancellation_reason_code = cancellation_reason_code;

    let uri_str = format!("{}/service/v1/serviceJobs/{serviceJobId}/cancellations", configuration.base_path, serviceJobId=crate::apis::urlencode(p_service_job_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    req_builder = req_builder.query(&[("cancellationReasonCode", &p_cancellation_reason_code.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::services::CancelServiceJobByServiceJobIdResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::services::CancelServiceJobByServiceJobIdResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CancelServiceJobByServiceJobIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Completes the service job indicated by the service job identifier specified.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).
pub async fn complete_service_job_by_service_job_id(configuration: &configuration::Configuration, service_job_id: &str) -> Result<models::services::CompleteServiceJobByServiceJobIdResponse, Error<CompleteServiceJobByServiceJobIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_service_job_id = service_job_id;

    let uri_str = format!("{}/service/v1/serviceJobs/{serviceJobId}/completions", configuration.base_path, serviceJobId=crate::apis::urlencode(p_service_job_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::services::CompleteServiceJobByServiceJobIdResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::services::CompleteServiceJobByServiceJobIdResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CompleteServiceJobByServiceJobIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a reservation.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).
pub async fn create_reservation(configuration: &configuration::Configuration, marketplace_ids: Vec<String>, body: models::services::CreateReservationRequest) -> Result<models::services::CreateReservationResponse, Error<CreateReservationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_marketplace_ids = marketplace_ids;
    let p_body = body;

    let uri_str = format!("{}/service/v1/reservation", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = match "csv" {
        "multi" => req_builder.query(&p_marketplace_ids.into_iter().map(|p| ("marketplaceIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("marketplaceIds", &p_marketplace_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::services::CreateReservationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::services::CreateReservationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateReservationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates an upload destination.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).
pub async fn create_service_document_upload_destination(configuration: &configuration::Configuration, body: models::services::ServiceUploadDocument) -> Result<models::services::CreateServiceDocumentUploadDestination, Error<CreateServiceDocumentUploadDestinationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body = body;

    let uri_str = format!("{}/service/v1/documents", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::services::CreateServiceDocumentUploadDestination`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::services::CreateServiceDocumentUploadDestination`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateServiceDocumentUploadDestinationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets appointment slots as per the service context specified.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 20 | 40 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).
pub async fn get_appointment_slots(configuration: &configuration::Configuration, asin: &str, store_id: &str, marketplace_ids: Vec<String>, start_time: Option<&str>, end_time: Option<&str>) -> Result<models::services::GetAppointmentSlotsResponse, Error<GetAppointmentSlotsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_asin = asin;
    let p_store_id = store_id;
    let p_marketplace_ids = marketplace_ids;
    let p_start_time = start_time;
    let p_end_time = end_time;

    let uri_str = format!("{}/service/v1/appointmentSlots", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("asin", &p_asin.to_string())]);
    req_builder = req_builder.query(&[("storeId", &p_store_id.to_string())]);
    req_builder = match "csv" {
        "multi" => req_builder.query(&p_marketplace_ids.into_iter().map(|p| ("marketplaceIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("marketplaceIds", &p_marketplace_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref param_value) = p_start_time {
        req_builder = req_builder.query(&[("startTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_time {
        req_builder = req_builder.query(&[("endTime", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::services::GetAppointmentSlotsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::services::GetAppointmentSlotsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAppointmentSlotsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets appointment slots for the service associated with the service job id specified.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).
pub async fn get_appointmment_slots_by_job_id(configuration: &configuration::Configuration, service_job_id: &str, marketplace_ids: Vec<String>, start_time: Option<&str>, end_time: Option<&str>) -> Result<models::services::GetAppointmentSlotsResponse, Error<GetAppointmmentSlotsByJobIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_service_job_id = service_job_id;
    let p_marketplace_ids = marketplace_ids;
    let p_start_time = start_time;
    let p_end_time = end_time;

    let uri_str = format!("{}/service/v1/serviceJobs/{serviceJobId}/appointmentSlots", configuration.base_path, serviceJobId=crate::apis::urlencode(p_service_job_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = match "csv" {
        "multi" => req_builder.query(&p_marketplace_ids.into_iter().map(|p| ("marketplaceIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("marketplaceIds", &p_marketplace_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref param_value) = p_start_time {
        req_builder = req_builder.query(&[("startTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_time {
        req_builder = req_builder.query(&[("endTime", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::services::GetAppointmentSlotsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::services::GetAppointmentSlotsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAppointmmentSlotsByJobIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Provides capacity in fixed-size slots.   **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).
pub async fn get_fixed_slot_capacity(configuration: &configuration::Configuration, resource_id: &str, marketplace_ids: Vec<String>, body: models::services::FixedSlotCapacityQuery, next_page_token: Option<&str>) -> Result<models::services::FixedSlotCapacity, Error<GetFixedSlotCapacityError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_resource_id = resource_id;
    let p_marketplace_ids = marketplace_ids;
    let p_body = body;
    let p_next_page_token = next_page_token;

    let uri_str = format!("{}/service/v1/serviceResources/{resourceId}/capacity/fixed", configuration.base_path, resourceId=crate::apis::urlencode(p_resource_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = match "csv" {
        "multi" => req_builder.query(&p_marketplace_ids.into_iter().map(|p| ("marketplaceIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("marketplaceIds", &p_marketplace_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref param_value) = p_next_page_token {
        req_builder = req_builder.query(&[("nextPageToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::services::FixedSlotCapacity`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::services::FixedSlotCapacity`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetFixedSlotCapacityError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Provides capacity slots in a format similar to availability records.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).
pub async fn get_range_slot_capacity(configuration: &configuration::Configuration, resource_id: &str, marketplace_ids: Vec<String>, body: models::services::RangeSlotCapacityQuery, next_page_token: Option<&str>) -> Result<models::services::RangeSlotCapacity, Error<GetRangeSlotCapacityError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_resource_id = resource_id;
    let p_marketplace_ids = marketplace_ids;
    let p_body = body;
    let p_next_page_token = next_page_token;

    let uri_str = format!("{}/service/v1/serviceResources/{resourceId}/capacity/range", configuration.base_path, resourceId=crate::apis::urlencode(p_resource_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = match "csv" {
        "multi" => req_builder.query(&p_marketplace_ids.into_iter().map(|p| ("marketplaceIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("marketplaceIds", &p_marketplace_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref param_value) = p_next_page_token {
        req_builder = req_builder.query(&[("nextPageToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::services::RangeSlotCapacity`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::services::RangeSlotCapacity`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetRangeSlotCapacityError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets details of service job indicated by the provided `serviceJobID`.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 20 | 40 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).
pub async fn get_service_job_by_service_job_id(configuration: &configuration::Configuration, service_job_id: &str) -> Result<models::services::GetServiceJobByServiceJobIdResponse, Error<GetServiceJobByServiceJobIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_service_job_id = service_job_id;

    let uri_str = format!("{}/service/v1/serviceJobs/{serviceJobId}", configuration.base_path, serviceJobId=crate::apis::urlencode(p_service_job_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::services::GetServiceJobByServiceJobIdResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::services::GetServiceJobByServiceJobIdResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetServiceJobByServiceJobIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets service job details for the specified filter query.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 10 | 40 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).
pub async fn get_service_jobs(configuration: &configuration::Configuration, marketplace_ids: Vec<String>, service_order_ids: Option<Vec<String>>, service_job_status: Option<Vec<String>>, page_token: Option<&str>, page_size: Option<i32>, sort_field: Option<&str>, sort_order: Option<&str>, created_after: Option<&str>, created_before: Option<&str>, last_updated_after: Option<&str>, last_updated_before: Option<&str>, schedule_start_date: Option<&str>, schedule_end_date: Option<&str>, asins: Option<Vec<String>>, required_skills: Option<Vec<String>>, store_ids: Option<Vec<String>>) -> Result<models::services::GetServiceJobsResponse, Error<GetServiceJobsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_marketplace_ids = marketplace_ids;
    let p_service_order_ids = service_order_ids;
    let p_service_job_status = service_job_status;
    let p_page_token = page_token;
    let p_page_size = page_size;
    let p_sort_field = sort_field;
    let p_sort_order = sort_order;
    let p_created_after = created_after;
    let p_created_before = created_before;
    let p_last_updated_after = last_updated_after;
    let p_last_updated_before = last_updated_before;
    let p_schedule_start_date = schedule_start_date;
    let p_schedule_end_date = schedule_end_date;
    let p_asins = asins;
    let p_required_skills = required_skills;
    let p_store_ids = store_ids;

    let uri_str = format!("{}/service/v1/serviceJobs", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_service_order_ids {
        req_builder = match "csv" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("serviceOrderIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("serviceOrderIds", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_service_job_status {
        req_builder = match "csv" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("serviceJobStatus".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("serviceJobStatus", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_page_token {
        req_builder = req_builder.query(&[("pageToken", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("pageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_field {
        req_builder = req_builder.query(&[("sortField", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_order {
        req_builder = req_builder.query(&[("sortOrder", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_created_after {
        req_builder = req_builder.query(&[("createdAfter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_created_before {
        req_builder = req_builder.query(&[("createdBefore", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_last_updated_after {
        req_builder = req_builder.query(&[("lastUpdatedAfter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_last_updated_before {
        req_builder = req_builder.query(&[("lastUpdatedBefore", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_schedule_start_date {
        req_builder = req_builder.query(&[("scheduleStartDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_schedule_end_date {
        req_builder = req_builder.query(&[("scheduleEndDate", &param_value.to_string())]);
    }
    req_builder = match "csv" {
        "multi" => req_builder.query(&p_marketplace_ids.into_iter().map(|p| ("marketplaceIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("marketplaceIds", &p_marketplace_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref param_value) = p_asins {
        req_builder = match "csv" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("asins".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("asins", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_required_skills {
        req_builder = match "csv" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("requiredSkills".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("requiredSkills", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_store_ids {
        req_builder = match "csv" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("storeIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("storeIds", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::services::GetServiceJobsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::services::GetServiceJobsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetServiceJobsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Reschedules an appointment for the service job indicated by the service job identifier specified.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).
pub async fn reschedule_appointment_for_service_job_by_service_job_id(configuration: &configuration::Configuration, service_job_id: &str, appointment_id: &str, body: models::services::RescheduleAppointmentRequest) -> Result<models::services::SetAppointmentResponse, Error<RescheduleAppointmentForServiceJobByServiceJobIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_service_job_id = service_job_id;
    let p_appointment_id = appointment_id;
    let p_body = body;

    let uri_str = format!("{}/service/v1/serviceJobs/{serviceJobId}/appointments/{appointmentId}", configuration.base_path, serviceJobId=crate::apis::urlencode(p_service_job_id), appointmentId=crate::apis::urlencode(p_appointment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::services::SetAppointmentResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::services::SetAppointmentResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RescheduleAppointmentForServiceJobByServiceJobIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the appointment fulfillment data related to a given `jobID` and `appointmentID`.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).
pub async fn set_appointment_fulfillment_data(configuration: &configuration::Configuration, service_job_id: &str, appointment_id: &str, body: models::services::SetAppointmentFulfillmentDataRequest) -> Result<String, Error<SetAppointmentFulfillmentDataError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_service_job_id = service_job_id;
    let p_appointment_id = appointment_id;
    let p_body = body;

    let uri_str = format!("{}/service/v1/serviceJobs/{serviceJobId}/appointments/{appointmentId}/fulfillment", configuration.base_path, serviceJobId=crate::apis::urlencode(p_service_job_id), appointmentId=crate::apis::urlencode(p_appointment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `String`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SetAppointmentFulfillmentDataError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update a reservation.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).
pub async fn update_reservation(configuration: &configuration::Configuration, reservation_id: &str, marketplace_ids: Vec<String>, body: models::services::UpdateReservationRequest) -> Result<models::services::UpdateReservationResponse, Error<UpdateReservationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_reservation_id = reservation_id;
    let p_marketplace_ids = marketplace_ids;
    let p_body = body;

    let uri_str = format!("{}/service/v1/reservation/{reservationId}", configuration.base_path, reservationId=crate::apis::urlencode(p_reservation_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    req_builder = match "csv" {
        "multi" => req_builder.query(&p_marketplace_ids.into_iter().map(|p| ("marketplaceIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("marketplaceIds", &p_marketplace_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::services::UpdateReservationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::services::UpdateReservationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateReservationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update the schedule of the given resource.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).
pub async fn update_schedule(configuration: &configuration::Configuration, resource_id: &str, marketplace_ids: Vec<String>, body: models::services::UpdateScheduleRequest) -> Result<models::services::UpdateScheduleResponse, Error<UpdateScheduleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_resource_id = resource_id;
    let p_marketplace_ids = marketplace_ids;
    let p_body = body;

    let uri_str = format!("{}/service/v1/serviceResources/{resourceId}/schedules", configuration.base_path, resourceId=crate::apis::urlencode(p_resource_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    req_builder = match "csv" {
        "multi" => req_builder.query(&p_marketplace_ids.into_iter().map(|p| ("marketplaceIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("marketplaceIds", &p_marketplace_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::services::UpdateScheduleResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::services::UpdateScheduleResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateScheduleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

