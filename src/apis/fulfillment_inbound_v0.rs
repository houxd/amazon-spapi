/*
 * Selling Partner API for Fulfillment Inbound
 *
 * The Selling Partner API for Fulfillment Inbound lets you create applications that create and update inbound shipments of inventory to Amazon's fulfillment network.
 *
 * The version of the OpenAPI document: v0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`get_bill_of_lading`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBillOfLadingError {
    Status400(models::fulfillment_inbound_v0::GetBillOfLadingResponse),
    Status401(models::fulfillment_inbound_v0::GetBillOfLadingResponse),
    Status403(models::fulfillment_inbound_v0::GetBillOfLadingResponse),
    Status404(models::fulfillment_inbound_v0::GetBillOfLadingResponse),
    Status429(models::fulfillment_inbound_v0::GetBillOfLadingResponse),
    Status500(models::fulfillment_inbound_v0::GetBillOfLadingResponse),
    Status503(models::fulfillment_inbound_v0::GetBillOfLadingResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_labels`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetLabelsError {
    Status400(models::fulfillment_inbound_v0::GetLabelsResponse),
    Status401(models::fulfillment_inbound_v0::GetLabelsResponse),
    Status403(models::fulfillment_inbound_v0::GetLabelsResponse),
    Status404(models::fulfillment_inbound_v0::GetLabelsResponse),
    Status429(models::fulfillment_inbound_v0::GetLabelsResponse),
    Status500(models::fulfillment_inbound_v0::GetLabelsResponse),
    Status503(models::fulfillment_inbound_v0::GetLabelsResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_prep_instructions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPrepInstructionsError {
    Status400(models::fulfillment_inbound_v0::GetPrepInstructionsResponse),
    Status401(models::fulfillment_inbound_v0::GetPrepInstructionsResponse),
    Status403(models::fulfillment_inbound_v0::GetPrepInstructionsResponse),
    Status404(models::fulfillment_inbound_v0::GetPrepInstructionsResponse),
    Status429(models::fulfillment_inbound_v0::GetPrepInstructionsResponse),
    Status500(models::fulfillment_inbound_v0::GetPrepInstructionsResponse),
    Status503(models::fulfillment_inbound_v0::GetPrepInstructionsResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_shipment_items`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetShipmentItemsError {
    Status400(models::fulfillment_inbound_v0::GetShipmentItemsResponse),
    Status401(models::fulfillment_inbound_v0::GetShipmentItemsResponse),
    Status403(models::fulfillment_inbound_v0::GetShipmentItemsResponse),
    Status404(models::fulfillment_inbound_v0::GetShipmentItemsResponse),
    Status429(models::fulfillment_inbound_v0::GetShipmentItemsResponse),
    Status500(models::fulfillment_inbound_v0::GetShipmentItemsResponse),
    Status503(models::fulfillment_inbound_v0::GetShipmentItemsResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_shipment_items_by_shipment_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetShipmentItemsByShipmentIdError {
    Status400(models::fulfillment_inbound_v0::GetShipmentItemsResponse),
    Status401(models::fulfillment_inbound_v0::GetShipmentItemsResponse),
    Status403(models::fulfillment_inbound_v0::GetShipmentItemsResponse),
    Status404(models::fulfillment_inbound_v0::GetShipmentItemsResponse),
    Status429(models::fulfillment_inbound_v0::GetShipmentItemsResponse),
    Status500(models::fulfillment_inbound_v0::GetShipmentItemsResponse),
    Status503(models::fulfillment_inbound_v0::GetShipmentItemsResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_shipments`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetShipmentsError {
    Status400(models::fulfillment_inbound_v0::GetShipmentsResponse),
    Status401(models::fulfillment_inbound_v0::GetShipmentsResponse),
    Status403(models::fulfillment_inbound_v0::GetShipmentsResponse),
    Status404(models::fulfillment_inbound_v0::GetShipmentsResponse),
    Status429(models::fulfillment_inbound_v0::GetShipmentsResponse),
    Status500(models::fulfillment_inbound_v0::GetShipmentsResponse),
    Status503(models::fulfillment_inbound_v0::GetShipmentsResponse),
    UnknownValue(serde_json::Value),
}


/// Returns a bill of lading for a Less Than Truckload/Full Truckload (LTL/FTL) shipment. The getBillOfLading operation returns PDF document data for printing a bill of lading for an Amazon-partnered Less Than Truckload/Full Truckload (LTL/FTL) inbound shipment.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 30 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn get_bill_of_lading(configuration: &configuration::Configuration, shipment_id: &str) -> Result<models::fulfillment_inbound_v0::GetBillOfLadingResponse, Error<GetBillOfLadingError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_shipment_id = shipment_id;

    let uri_str = format!("{}/fba/inbound/v0/shipments/{shipmentId}/billOfLading", configuration.base_path, shipmentId=crate::apis::urlencode(p_shipment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_v0::GetBillOfLadingResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_v0::GetBillOfLadingResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetBillOfLadingError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns package/pallet labels for faster and more accurate shipment processing at the Amazon fulfillment center.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 30 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn get_labels(configuration: &configuration::Configuration, shipment_id: &str, page_type: &str, label_type: &str, number_of_packages: Option<i32>, package_labels_to_print: Option<Vec<String>>, number_of_pallets: Option<i32>, page_size: Option<i32>, page_start_index: Option<i32>) -> Result<models::fulfillment_inbound_v0::GetLabelsResponse, Error<GetLabelsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_shipment_id = shipment_id;
    let p_page_type = page_type;
    let p_label_type = label_type;
    let p_number_of_packages = number_of_packages;
    let p_package_labels_to_print = package_labels_to_print;
    let p_number_of_pallets = number_of_pallets;
    let p_page_size = page_size;
    let p_page_start_index = page_start_index;

    let uri_str = format!("{}/fba/inbound/v0/shipments/{shipmentId}/labels", configuration.base_path, shipmentId=crate::apis::urlencode(p_shipment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("PageType", &p_page_type.to_string())]);
    req_builder = req_builder.query(&[("LabelType", &p_label_type.to_string())]);
    if let Some(ref param_value) = p_number_of_packages {
        req_builder = req_builder.query(&[("NumberOfPackages", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_package_labels_to_print {
        req_builder = match "csv" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("PackageLabelsToPrint".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("PackageLabelsToPrint", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_number_of_pallets {
        req_builder = req_builder.query(&[("NumberOfPallets", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("PageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_start_index {
        req_builder = req_builder.query(&[("PageStartIndex", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_v0::GetLabelsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_v0::GetLabelsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetLabelsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns labeling requirements and item preparation instructions to help prepare items for shipment to Amazon's fulfillment network.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 30 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn get_prep_instructions(configuration: &configuration::Configuration, ship_to_country_code: &str, seller_sku_list: Option<Vec<String>>, asin_list: Option<Vec<String>>) -> Result<models::fulfillment_inbound_v0::GetPrepInstructionsResponse, Error<GetPrepInstructionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_ship_to_country_code = ship_to_country_code;
    let p_seller_sku_list = seller_sku_list;
    let p_asin_list = asin_list;

    let uri_str = format!("{}/fba/inbound/v0/prepInstructions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("ShipToCountryCode", &p_ship_to_country_code.to_string())]);
    if let Some(ref param_value) = p_seller_sku_list {
        req_builder = match "csv" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("SellerSKUList".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("SellerSKUList", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_asin_list {
        req_builder = match "csv" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("ASINList".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("ASINList", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_v0::GetPrepInstructionsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_v0::GetPrepInstructionsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPrepInstructionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a list of items in a specified inbound shipment, or a list of items that were updated within a specified time frame.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 30 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn get_shipment_items(configuration: &configuration::Configuration, query_type: &str, marketplace_id: &str, last_updated_after: Option<String>, last_updated_before: Option<String>, next_token: Option<&str>) -> Result<models::fulfillment_inbound_v0::GetShipmentItemsResponse, Error<GetShipmentItemsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_type = query_type;
    let p_marketplace_id = marketplace_id;
    let p_last_updated_after = last_updated_after;
    let p_last_updated_before = last_updated_before;
    let p_next_token = next_token;

    let uri_str = format!("{}/fba/inbound/v0/shipmentItems", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_last_updated_after {
        req_builder = req_builder.query(&[("LastUpdatedAfter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_last_updated_before {
        req_builder = req_builder.query(&[("LastUpdatedBefore", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("QueryType", &p_query_type.to_string())]);
    if let Some(ref param_value) = p_next_token {
        req_builder = req_builder.query(&[("NextToken", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("MarketplaceId", &p_marketplace_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_v0::GetShipmentItemsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_v0::GetShipmentItemsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetShipmentItemsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a list of items in a specified inbound shipment.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 30 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn get_shipment_items_by_shipment_id(configuration: &configuration::Configuration, shipment_id: &str, marketplace_id: Option<&str>) -> Result<models::fulfillment_inbound_v0::GetShipmentItemsResponse, Error<GetShipmentItemsByShipmentIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_shipment_id = shipment_id;
    let p_marketplace_id = marketplace_id;

    let uri_str = format!("{}/fba/inbound/v0/shipments/{shipmentId}/items", configuration.base_path, shipmentId=crate::apis::urlencode(p_shipment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_marketplace_id {
        req_builder = req_builder.query(&[("MarketplaceId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_v0::GetShipmentItemsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_v0::GetShipmentItemsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetShipmentItemsByShipmentIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a list of inbound shipments based on criteria that you specify.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 30 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn get_shipments(configuration: &configuration::Configuration, query_type: &str, marketplace_id: &str, shipment_status_list: Option<Vec<String>>, shipment_id_list: Option<Vec<String>>, last_updated_after: Option<String>, last_updated_before: Option<String>, next_token: Option<&str>) -> Result<models::fulfillment_inbound_v0::GetShipmentsResponse, Error<GetShipmentsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_type = query_type;
    let p_marketplace_id = marketplace_id;
    let p_shipment_status_list = shipment_status_list;
    let p_shipment_id_list = shipment_id_list;
    let p_last_updated_after = last_updated_after;
    let p_last_updated_before = last_updated_before;
    let p_next_token = next_token;

    let uri_str = format!("{}/fba/inbound/v0/shipments", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_shipment_status_list {
        req_builder = match "csv" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("ShipmentStatusList".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("ShipmentStatusList", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_shipment_id_list {
        req_builder = match "csv" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("ShipmentIdList".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("ShipmentIdList", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_last_updated_after {
        req_builder = req_builder.query(&[("LastUpdatedAfter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_last_updated_before {
        req_builder = req_builder.query(&[("LastUpdatedBefore", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("QueryType", &p_query_type.to_string())]);
    if let Some(ref param_value) = p_next_token {
        req_builder = req_builder.query(&[("NextToken", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("MarketplaceId", &p_marketplace_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_v0::GetShipmentsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_v0::GetShipmentsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetShipmentsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

