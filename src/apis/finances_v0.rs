/*
 * Selling Partner API for Finances
 *
 * The Selling Partner API for Finances helps you obtain financial information relevant to a seller's business. You can obtain financial events for a given order, financial event group, or date range without having to wait until a statement period closes. You can also obtain financial event groups for a given date range.
 *
 * The version of the OpenAPI document: v0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`list_financial_event_groups`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListFinancialEventGroupsError {
    Status400(models::finances_v0::ListFinancialEventGroupsResponse),
    Status403(models::finances_v0::ListFinancialEventGroupsResponse),
    Status404(models::finances_v0::ListFinancialEventGroupsResponse),
    Status429(models::finances_v0::ListFinancialEventGroupsResponse),
    Status500(models::finances_v0::ListFinancialEventGroupsResponse),
    Status503(models::finances_v0::ListFinancialEventGroupsResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_financial_events`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListFinancialEventsError {
    Status400(models::finances_v0::ListFinancialEventsResponse),
    Status403(models::finances_v0::ListFinancialEventsResponse),
    Status404(models::finances_v0::ListFinancialEventsResponse),
    Status429(models::finances_v0::ListFinancialEventsResponse),
    Status500(models::finances_v0::ListFinancialEventsResponse),
    Status503(models::finances_v0::ListFinancialEventsResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_financial_events_by_group_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListFinancialEventsByGroupIdError {
    Status400(models::finances_v0::ListFinancialEventsResponse),
    Status403(models::finances_v0::ListFinancialEventsResponse),
    Status404(models::finances_v0::ListFinancialEventsResponse),
    Status429(models::finances_v0::ListFinancialEventsResponse),
    Status500(models::finances_v0::ListFinancialEventsResponse),
    Status503(models::finances_v0::ListFinancialEventsResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_financial_events_by_order_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListFinancialEventsByOrderIdError {
    Status400(models::finances_v0::ListFinancialEventsResponse),
    Status403(models::finances_v0::ListFinancialEventsResponse),
    Status404(models::finances_v0::ListFinancialEventsResponse),
    Status429(models::finances_v0::ListFinancialEventsResponse),
    Status500(models::finances_v0::ListFinancialEventsResponse),
    Status503(models::finances_v0::ListFinancialEventsResponse),
    UnknownValue(serde_json::Value),
}


/// Returns financial event groups for a given date range. It may take up to 48 hours for orders to appear in your financial events.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 0.5 | 30 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn list_financial_event_groups(configuration: &configuration::Configuration, max_results_per_page: Option<i32>, financial_event_group_started_before: Option<String>, financial_event_group_started_after: Option<String>, next_token: Option<&str>) -> Result<models::finances_v0::ListFinancialEventGroupsResponse, Error<ListFinancialEventGroupsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_max_results_per_page = max_results_per_page;
    let p_financial_event_group_started_before = financial_event_group_started_before;
    let p_financial_event_group_started_after = financial_event_group_started_after;
    let p_next_token = next_token;

    let uri_str = format!("{}/finances/v0/financialEventGroups", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_max_results_per_page {
        req_builder = req_builder.query(&[("MaxResultsPerPage", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_financial_event_group_started_before {
        req_builder = req_builder.query(&[("FinancialEventGroupStartedBefore", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_financial_event_group_started_after {
        req_builder = req_builder.query(&[("FinancialEventGroupStartedAfter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_next_token {
        req_builder = req_builder.query(&[("NextToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::finances_v0::ListFinancialEventGroupsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::finances_v0::ListFinancialEventGroupsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListFinancialEventGroupsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns financial events for the specified data range. It may take up to 48 hours for orders to appear in your financial events. **Note:** in `ListFinancialEvents`, deferred events don't show up in responses until in they are released.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 0.5 | 30 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn list_financial_events(configuration: &configuration::Configuration, max_results_per_page: Option<i32>, posted_after: Option<String>, posted_before: Option<String>, next_token: Option<&str>) -> Result<models::finances_v0::ListFinancialEventsResponse, Error<ListFinancialEventsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_max_results_per_page = max_results_per_page;
    let p_posted_after = posted_after;
    let p_posted_before = posted_before;
    let p_next_token = next_token;

    let uri_str = format!("{}/finances/v0/financialEvents", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_max_results_per_page {
        req_builder = req_builder.query(&[("MaxResultsPerPage", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_posted_after {
        req_builder = req_builder.query(&[("PostedAfter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_posted_before {
        req_builder = req_builder.query(&[("PostedBefore", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_next_token {
        req_builder = req_builder.query(&[("NextToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::finances_v0::ListFinancialEventsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::finances_v0::ListFinancialEventsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListFinancialEventsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns all financial events for the specified financial event group. It may take up to 48 hours for orders to appear in your financial events.  **Note:** This operation will only retrieve group's data for the past two years. If a request is submitted for data spanning more than two years, an empty response is returned.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 0.5 | 30 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn list_financial_events_by_group_id(configuration: &configuration::Configuration, event_group_id: &str, max_results_per_page: Option<i32>, posted_after: Option<String>, posted_before: Option<String>, next_token: Option<&str>) -> Result<models::finances_v0::ListFinancialEventsResponse, Error<ListFinancialEventsByGroupIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_event_group_id = event_group_id;
    let p_max_results_per_page = max_results_per_page;
    let p_posted_after = posted_after;
    let p_posted_before = posted_before;
    let p_next_token = next_token;

    let uri_str = format!("{}/finances/v0/financialEventGroups/{eventGroupId}/financialEvents", configuration.base_path, eventGroupId=crate::apis::urlencode(p_event_group_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_max_results_per_page {
        req_builder = req_builder.query(&[("MaxResultsPerPage", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_posted_after {
        req_builder = req_builder.query(&[("PostedAfter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_posted_before {
        req_builder = req_builder.query(&[("PostedBefore", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_next_token {
        req_builder = req_builder.query(&[("NextToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::finances_v0::ListFinancialEventsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::finances_v0::ListFinancialEventsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListFinancialEventsByGroupIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns all financial events for the specified order. It may take up to 48 hours for orders to appear in your financial events.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 0.5 | 30 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn list_financial_events_by_order_id(configuration: &configuration::Configuration, order_id: &str, max_results_per_page: Option<i32>, next_token: Option<&str>) -> Result<models::finances_v0::ListFinancialEventsResponse, Error<ListFinancialEventsByOrderIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_order_id = order_id;
    let p_max_results_per_page = max_results_per_page;
    let p_next_token = next_token;

    let uri_str = format!("{}/finances/v0/orders/{orderId}/financialEvents", configuration.base_path, orderId=crate::apis::urlencode(p_order_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_max_results_per_page {
        req_builder = req_builder.query(&[("MaxResultsPerPage", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_next_token {
        req_builder = req_builder.query(&[("NextToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::finances_v0::ListFinancialEventsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::finances_v0::ListFinancialEventsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListFinancialEventsByOrderIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

