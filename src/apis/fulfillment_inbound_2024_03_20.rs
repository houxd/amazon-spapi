/*
 * The Selling Partner API for FBA inbound operations.
 *
 * The Selling Partner API for Fulfillment By Amazon (FBA) Inbound. The FBA Inbound API enables building inbound workflows to create, manage, and send shipments into Amazon's fulfillment network. The API has interoperability with the Send-to-Amazon user interface.
 *
 * The version of the OpenAPI document: 2024-03-20
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`cancel_inbound_plan`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CancelInboundPlanError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cancel_self_ship_appointment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CancelSelfShipAppointmentError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`confirm_delivery_window_options`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfirmDeliveryWindowOptionsError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`confirm_packing_option`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfirmPackingOptionError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`confirm_placement_option`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfirmPlacementOptionError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`confirm_shipment_content_update_preview`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfirmShipmentContentUpdatePreviewError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`confirm_transportation_options`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfirmTransportationOptionsError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_inbound_plan`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateInboundPlanError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_marketplace_item_labels`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMarketplaceItemLabelsError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`generate_delivery_window_options`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GenerateDeliveryWindowOptionsError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`generate_packing_options`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GeneratePackingOptionsError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`generate_placement_options`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GeneratePlacementOptionsError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`generate_self_ship_appointment_slots`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GenerateSelfShipAppointmentSlotsError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`generate_shipment_content_update_previews`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GenerateShipmentContentUpdatePreviewsError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`generate_transportation_options`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GenerateTransportationOptionsError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_delivery_challan_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDeliveryChallanDocumentError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_inbound_operation_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetInboundOperationStatusError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_inbound_plan`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetInboundPlanError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_self_ship_appointment_slots`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSelfShipAppointmentSlotsError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_shipment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetShipmentError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_shipment_content_update_preview`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetShipmentContentUpdatePreviewError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_delivery_window_options`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListDeliveryWindowOptionsError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_inbound_plan_boxes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListInboundPlanBoxesError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_inbound_plan_items`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListInboundPlanItemsError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_inbound_plan_pallets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListInboundPlanPalletsError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_inbound_plans`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListInboundPlansError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_item_compliance_details`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListItemComplianceDetailsError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_packing_group_boxes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListPackingGroupBoxesError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_packing_group_items`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListPackingGroupItemsError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_packing_options`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListPackingOptionsError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_placement_options`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListPlacementOptionsError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_prep_details`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListPrepDetailsError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_shipment_boxes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListShipmentBoxesError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_shipment_content_update_previews`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListShipmentContentUpdatePreviewsError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_shipment_items`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListShipmentItemsError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_shipment_pallets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListShipmentPalletsError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_transportation_options`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListTransportationOptionsError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`schedule_self_ship_appointment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ScheduleSelfShipAppointmentError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_packing_information`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetPackingInformationError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_prep_details`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetPrepDetailsError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_inbound_plan_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateInboundPlanNameError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_item_compliance_details`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateItemComplianceDetailsError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_shipment_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateShipmentNameError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_shipment_source_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateShipmentSourceAddressError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_shipment_tracking_details`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateShipmentTrackingDetailsError {
    Status400(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status404(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status500(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status403(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status413(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status415(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status429(models::fulfillment_inbound_2024_03_20::ErrorList),
    Status503(models::fulfillment_inbound_2024_03_20::ErrorList),
    UnknownValue(serde_json::Value),
}


/// Cancels an Inbound Plan. Charges may apply if the cancellation is performed outside of a void window. The window for Amazon Partnered Carriers is 24 hours for Small Parcel Delivery (SPD) and one hour for Less-Than-Truckload (LTL) carrier shipments.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 2 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn cancel_inbound_plan(configuration: &configuration::Configuration, inbound_plan_id: &str) -> Result<models::fulfillment_inbound_2024_03_20::CancelInboundPlanResponse, Error<CancelInboundPlanError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inbound_plan_id = inbound_plan_id;

    let uri_str = format!("{}/inbound/fba/2024-03-20/inboundPlans/{inboundPlanId}/cancellation", configuration.base_path, inboundPlanId=crate::apis::urlencode(p_inbound_plan_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::CancelInboundPlanResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::CancelInboundPlanResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CancelInboundPlanError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancels a self-ship appointment slot against a shipment. Only available in the following [marketplaces](https://developer-docs.amazon.com/sp-api/docs/marketplace-ids): MX, BR, EG, SA, AE, IN.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 30 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api). 
pub async fn cancel_self_ship_appointment(configuration: &configuration::Configuration, inbound_plan_id: &str, shipment_id: &str, body: models::fulfillment_inbound_2024_03_20::CancelSelfShipAppointmentRequest) -> Result<models::fulfillment_inbound_2024_03_20::CancelSelfShipAppointmentResponse, Error<CancelSelfShipAppointmentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inbound_plan_id = inbound_plan_id;
    let p_shipment_id = shipment_id;
    let p_body = body;

    let uri_str = format!("{}/inbound/fba/2024-03-20/inboundPlans/{inboundPlanId}/shipments/{shipmentId}/selfShipAppointmentCancellation", configuration.base_path, inboundPlanId=crate::apis::urlencode(p_inbound_plan_id), shipmentId=crate::apis::urlencode(p_shipment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::CancelSelfShipAppointmentResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::CancelSelfShipAppointmentResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CancelSelfShipAppointmentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Confirms the delivery window option for chosen shipment within an inbound plan. A placement option must be confirmed prior to use of this API. Once confirmed, new delivery window options cannot be generated, but the chosen delivery window option can be updated before shipment closure. The window is used to provide the expected time when a shipment will arrive at the warehouse. All transportation options which have the program `CONFIRMED_DELIVERY_WINDOW` require a delivery window to be confirmed prior to transportation option confirmation.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 30 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn confirm_delivery_window_options(configuration: &configuration::Configuration, inbound_plan_id: &str, shipment_id: &str, delivery_window_option_id: &str) -> Result<models::fulfillment_inbound_2024_03_20::ConfirmDeliveryWindowOptionsResponse, Error<ConfirmDeliveryWindowOptionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inbound_plan_id = inbound_plan_id;
    let p_shipment_id = shipment_id;
    let p_delivery_window_option_id = delivery_window_option_id;

    let uri_str = format!("{}/inbound/fba/2024-03-20/inboundPlans/{inboundPlanId}/shipments/{shipmentId}/deliveryWindowOptions/{deliveryWindowOptionId}/confirmation", configuration.base_path, inboundPlanId=crate::apis::urlencode(p_inbound_plan_id), shipmentId=crate::apis::urlencode(p_shipment_id), deliveryWindowOptionId=crate::apis::urlencode(p_delivery_window_option_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ConfirmDeliveryWindowOptionsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ConfirmDeliveryWindowOptionsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfirmDeliveryWindowOptionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Confirms the packing option for an inbound plan.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 2 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn confirm_packing_option(configuration: &configuration::Configuration, inbound_plan_id: &str, packing_option_id: &str) -> Result<models::fulfillment_inbound_2024_03_20::ConfirmPackingOptionResponse, Error<ConfirmPackingOptionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inbound_plan_id = inbound_plan_id;
    let p_packing_option_id = packing_option_id;

    let uri_str = format!("{}/inbound/fba/2024-03-20/inboundPlans/{inboundPlanId}/packingOptions/{packingOptionId}/confirmation", configuration.base_path, inboundPlanId=crate::apis::urlencode(p_inbound_plan_id), packingOptionId=crate::apis::urlencode(p_packing_option_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ConfirmPackingOptionResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ConfirmPackingOptionResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfirmPackingOptionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Confirms the placement option for an inbound plan. Once confirmed, it cannot be changed for the Inbound Plan.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 2 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn confirm_placement_option(configuration: &configuration::Configuration, inbound_plan_id: &str, placement_option_id: &str) -> Result<models::fulfillment_inbound_2024_03_20::ConfirmPlacementOptionResponse, Error<ConfirmPlacementOptionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inbound_plan_id = inbound_plan_id;
    let p_placement_option_id = placement_option_id;

    let uri_str = format!("{}/inbound/fba/2024-03-20/inboundPlans/{inboundPlanId}/placementOptions/{placementOptionId}/confirmation", configuration.base_path, inboundPlanId=crate::apis::urlencode(p_inbound_plan_id), placementOptionId=crate::apis::urlencode(p_placement_option_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ConfirmPlacementOptionResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ConfirmPlacementOptionResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfirmPlacementOptionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Confirm a shipment content update preview and accept the changes in transportation cost.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 30 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn confirm_shipment_content_update_preview(configuration: &configuration::Configuration, inbound_plan_id: &str, shipment_id: &str, content_update_preview_id: &str) -> Result<models::fulfillment_inbound_2024_03_20::ConfirmShipmentContentUpdatePreviewResponse, Error<ConfirmShipmentContentUpdatePreviewError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inbound_plan_id = inbound_plan_id;
    let p_shipment_id = shipment_id;
    let p_content_update_preview_id = content_update_preview_id;

    let uri_str = format!("{}/inbound/fba/2024-03-20/inboundPlans/{inboundPlanId}/shipments/{shipmentId}/contentUpdatePreviews/{contentUpdatePreviewId}/confirmation", configuration.base_path, inboundPlanId=crate::apis::urlencode(p_inbound_plan_id), shipmentId=crate::apis::urlencode(p_shipment_id), contentUpdatePreviewId=crate::apis::urlencode(p_content_update_preview_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ConfirmShipmentContentUpdatePreviewResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ConfirmShipmentContentUpdatePreviewResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfirmShipmentContentUpdatePreviewError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Confirms all the transportation options for an inbound plan. A placement option must be confirmed prior to use of this API. Once confirmed, new transportation options can not be generated or confirmed for the Inbound Plan.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 2 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn confirm_transportation_options(configuration: &configuration::Configuration, inbound_plan_id: &str, body: models::fulfillment_inbound_2024_03_20::ConfirmTransportationOptionsRequest) -> Result<models::fulfillment_inbound_2024_03_20::ConfirmTransportationOptionsResponse, Error<ConfirmTransportationOptionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inbound_plan_id = inbound_plan_id;
    let p_body = body;

    let uri_str = format!("{}/inbound/fba/2024-03-20/inboundPlans/{inboundPlanId}/transportationOptions/confirmation", configuration.base_path, inboundPlanId=crate::apis::urlencode(p_inbound_plan_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ConfirmTransportationOptionsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ConfirmTransportationOptionsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfirmTransportationOptionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates an inbound plan. An inbound plan contains all the necessary information to send shipments into Amazon's fufillment network.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 2 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn create_inbound_plan(configuration: &configuration::Configuration, body: models::fulfillment_inbound_2024_03_20::CreateInboundPlanRequest) -> Result<models::fulfillment_inbound_2024_03_20::CreateInboundPlanResponse, Error<CreateInboundPlanError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body = body;

    let uri_str = format!("{}/inbound/fba/2024-03-20/inboundPlans", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::CreateInboundPlanResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::CreateInboundPlanResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateInboundPlanError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// For a given marketplace - creates labels for a list of MSKUs.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 30 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn create_marketplace_item_labels(configuration: &configuration::Configuration, body: models::fulfillment_inbound_2024_03_20::CreateMarketplaceItemLabelsRequest) -> Result<models::fulfillment_inbound_2024_03_20::CreateMarketplaceItemLabelsResponse, Error<CreateMarketplaceItemLabelsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body = body;

    let uri_str = format!("{}/inbound/fba/2024-03-20/items/labels", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::CreateMarketplaceItemLabelsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::CreateMarketplaceItemLabelsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateMarketplaceItemLabelsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Generates available delivery window options for a given shipment.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 30 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn generate_delivery_window_options(configuration: &configuration::Configuration, inbound_plan_id: &str, shipment_id: &str) -> Result<models::fulfillment_inbound_2024_03_20::GenerateDeliveryWindowOptionsResponse, Error<GenerateDeliveryWindowOptionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inbound_plan_id = inbound_plan_id;
    let p_shipment_id = shipment_id;

    let uri_str = format!("{}/inbound/fba/2024-03-20/inboundPlans/{inboundPlanId}/shipments/{shipmentId}/deliveryWindowOptions", configuration.base_path, inboundPlanId=crate::apis::urlencode(p_inbound_plan_id), shipmentId=crate::apis::urlencode(p_shipment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::GenerateDeliveryWindowOptionsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::GenerateDeliveryWindowOptionsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GenerateDeliveryWindowOptionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Generates available packing options for the inbound plan.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 2 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn generate_packing_options(configuration: &configuration::Configuration, inbound_plan_id: &str) -> Result<models::fulfillment_inbound_2024_03_20::GeneratePackingOptionsResponse, Error<GeneratePackingOptionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inbound_plan_id = inbound_plan_id;

    let uri_str = format!("{}/inbound/fba/2024-03-20/inboundPlans/{inboundPlanId}/packingOptions", configuration.base_path, inboundPlanId=crate::apis::urlencode(p_inbound_plan_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::GeneratePackingOptionsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::GeneratePackingOptionsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GeneratePackingOptionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Generates placement options for the inbound plan.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 2 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn generate_placement_options(configuration: &configuration::Configuration, inbound_plan_id: &str, body: models::fulfillment_inbound_2024_03_20::GeneratePlacementOptionsRequest) -> Result<models::fulfillment_inbound_2024_03_20::GeneratePlacementOptionsResponse, Error<GeneratePlacementOptionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inbound_plan_id = inbound_plan_id;
    let p_body = body;

    let uri_str = format!("{}/inbound/fba/2024-03-20/inboundPlans/{inboundPlanId}/placementOptions", configuration.base_path, inboundPlanId=crate::apis::urlencode(p_inbound_plan_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::GeneratePlacementOptionsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::GeneratePlacementOptionsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GeneratePlacementOptionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Initiates the process of generating the appointment slots list. Only available in the following [marketplaces](https://developer-docs.amazon.com/sp-api/docs/marketplace-ids): MX, BR, EG, SA, AE, IN.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 2 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api). 
pub async fn generate_self_ship_appointment_slots(configuration: &configuration::Configuration, inbound_plan_id: &str, shipment_id: &str, body: models::fulfillment_inbound_2024_03_20::GenerateSelfShipAppointmentSlotsRequest) -> Result<models::fulfillment_inbound_2024_03_20::GenerateSelfShipAppointmentSlotsResponse, Error<GenerateSelfShipAppointmentSlotsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inbound_plan_id = inbound_plan_id;
    let p_shipment_id = shipment_id;
    let p_body = body;

    let uri_str = format!("{}/inbound/fba/2024-03-20/inboundPlans/{inboundPlanId}/shipments/{shipmentId}/selfShipAppointmentSlots", configuration.base_path, inboundPlanId=crate::apis::urlencode(p_inbound_plan_id), shipmentId=crate::apis::urlencode(p_shipment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::GenerateSelfShipAppointmentSlotsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::GenerateSelfShipAppointmentSlotsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GenerateSelfShipAppointmentSlotsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Generate a shipment content update preview given a set of intended boxes and/or items for a shipment with a confirmed carrier. The shipment content update preview will be viewable with the updated costs and contents prior to confirmation.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 30 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn generate_shipment_content_update_previews(configuration: &configuration::Configuration, inbound_plan_id: &str, shipment_id: &str, body: models::fulfillment_inbound_2024_03_20::GenerateShipmentContentUpdatePreviewsRequest) -> Result<models::fulfillment_inbound_2024_03_20::GenerateShipmentContentUpdatePreviewsResponse, Error<GenerateShipmentContentUpdatePreviewsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inbound_plan_id = inbound_plan_id;
    let p_shipment_id = shipment_id;
    let p_body = body;

    let uri_str = format!("{}/inbound/fba/2024-03-20/inboundPlans/{inboundPlanId}/shipments/{shipmentId}/contentUpdatePreviews", configuration.base_path, inboundPlanId=crate::apis::urlencode(p_inbound_plan_id), shipmentId=crate::apis::urlencode(p_shipment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::GenerateShipmentContentUpdatePreviewsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::GenerateShipmentContentUpdatePreviewsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GenerateShipmentContentUpdatePreviewsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Generates available transportation options for a given placement option.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 2 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn generate_transportation_options(configuration: &configuration::Configuration, inbound_plan_id: &str, body: models::fulfillment_inbound_2024_03_20::GenerateTransportationOptionsRequest) -> Result<models::fulfillment_inbound_2024_03_20::GenerateTransportationOptionsResponse, Error<GenerateTransportationOptionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inbound_plan_id = inbound_plan_id;
    let p_body = body;

    let uri_str = format!("{}/inbound/fba/2024-03-20/inboundPlans/{inboundPlanId}/transportationOptions", configuration.base_path, inboundPlanId=crate::apis::urlencode(p_inbound_plan_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::GenerateTransportationOptionsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::GenerateTransportationOptionsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GenerateTransportationOptionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Provide delivery challan document for PCP transportation in IN marketplace.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 6 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn get_delivery_challan_document(configuration: &configuration::Configuration, inbound_plan_id: &str, shipment_id: &str) -> Result<models::fulfillment_inbound_2024_03_20::GetDeliveryChallanDocumentResponse, Error<GetDeliveryChallanDocumentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inbound_plan_id = inbound_plan_id;
    let p_shipment_id = shipment_id;

    let uri_str = format!("{}/inbound/fba/2024-03-20/inboundPlans/{inboundPlanId}/shipments/{shipmentId}/deliveryChallanDocument", configuration.base_path, inboundPlanId=crate::apis::urlencode(p_inbound_plan_id), shipmentId=crate::apis::urlencode(p_shipment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::GetDeliveryChallanDocumentResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::GetDeliveryChallanDocumentResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDeliveryChallanDocumentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets the status of the processing of an asynchronous API call.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 6 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn get_inbound_operation_status(configuration: &configuration::Configuration, operation_id: &str) -> Result<models::fulfillment_inbound_2024_03_20::InboundOperationStatus, Error<GetInboundOperationStatusError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_operation_id = operation_id;

    let uri_str = format!("{}/inbound/fba/2024-03-20/operations/{operationId}", configuration.base_path, operationId=crate::apis::urlencode(p_operation_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::InboundOperationStatus`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::InboundOperationStatus`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetInboundOperationStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetches the top level information about an inbound plan.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 6 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn get_inbound_plan(configuration: &configuration::Configuration, inbound_plan_id: &str) -> Result<models::fulfillment_inbound_2024_03_20::InboundPlan, Error<GetInboundPlanError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inbound_plan_id = inbound_plan_id;

    let uri_str = format!("{}/inbound/fba/2024-03-20/inboundPlans/{inboundPlanId}", configuration.base_path, inboundPlanId=crate::apis::urlencode(p_inbound_plan_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::InboundPlan`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::InboundPlan`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetInboundPlanError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves a list of available self-ship appointment slots used to drop off a shipment at a warehouse. Only available in the following [marketplaces](https://developer-docs.amazon.com/sp-api/docs/marketplace-ids): MX, BR, EG, SA, AE, IN.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 6 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api). 
pub async fn get_self_ship_appointment_slots(configuration: &configuration::Configuration, inbound_plan_id: &str, shipment_id: &str, page_size: Option<i32>, pagination_token: Option<&str>) -> Result<models::fulfillment_inbound_2024_03_20::GetSelfShipAppointmentSlotsResponse, Error<GetSelfShipAppointmentSlotsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inbound_plan_id = inbound_plan_id;
    let p_shipment_id = shipment_id;
    let p_page_size = page_size;
    let p_pagination_token = pagination_token;

    let uri_str = format!("{}/inbound/fba/2024-03-20/inboundPlans/{inboundPlanId}/shipments/{shipmentId}/selfShipAppointmentSlots", configuration.base_path, inboundPlanId=crate::apis::urlencode(p_inbound_plan_id), shipmentId=crate::apis::urlencode(p_shipment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("pageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_pagination_token {
        req_builder = req_builder.query(&[("paginationToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::GetSelfShipAppointmentSlotsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::GetSelfShipAppointmentSlotsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSelfShipAppointmentSlotsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Provides the full details for a specific shipment within an inbound plan. The `transportationOptionId` inside `acceptedTransportationSelection` can be used to retrieve the transportation details for the shipment.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 6 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn get_shipment(configuration: &configuration::Configuration, inbound_plan_id: &str, shipment_id: &str) -> Result<models::fulfillment_inbound_2024_03_20::Shipment, Error<GetShipmentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inbound_plan_id = inbound_plan_id;
    let p_shipment_id = shipment_id;

    let uri_str = format!("{}/inbound/fba/2024-03-20/inboundPlans/{inboundPlanId}/shipments/{shipmentId}", configuration.base_path, inboundPlanId=crate::apis::urlencode(p_inbound_plan_id), shipmentId=crate::apis::urlencode(p_shipment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::Shipment`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::Shipment`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetShipmentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve a shipment content update preview which provides a summary of the requested shipment content changes along with the transportation cost implications of the change that can only be confirmed prior to the expiry date specified.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 30 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn get_shipment_content_update_preview(configuration: &configuration::Configuration, inbound_plan_id: &str, shipment_id: &str, content_update_preview_id: &str) -> Result<models::fulfillment_inbound_2024_03_20::ContentUpdatePreview, Error<GetShipmentContentUpdatePreviewError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inbound_plan_id = inbound_plan_id;
    let p_shipment_id = shipment_id;
    let p_content_update_preview_id = content_update_preview_id;

    let uri_str = format!("{}/inbound/fba/2024-03-20/inboundPlans/{inboundPlanId}/shipments/{shipmentId}/contentUpdatePreviews/{contentUpdatePreviewId}", configuration.base_path, inboundPlanId=crate::apis::urlencode(p_inbound_plan_id), shipmentId=crate::apis::urlencode(p_shipment_id), contentUpdatePreviewId=crate::apis::urlencode(p_content_update_preview_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ContentUpdatePreview`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ContentUpdatePreview`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetShipmentContentUpdatePreviewError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves all delivery window options for a shipment. Delivery window options must first be generated by the `generateDeliveryWindowOptions` operation before becoming available.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 30 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn list_delivery_window_options(configuration: &configuration::Configuration, inbound_plan_id: &str, shipment_id: &str, page_size: Option<i32>, pagination_token: Option<&str>) -> Result<models::fulfillment_inbound_2024_03_20::ListDeliveryWindowOptionsResponse, Error<ListDeliveryWindowOptionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inbound_plan_id = inbound_plan_id;
    let p_shipment_id = shipment_id;
    let p_page_size = page_size;
    let p_pagination_token = pagination_token;

    let uri_str = format!("{}/inbound/fba/2024-03-20/inboundPlans/{inboundPlanId}/shipments/{shipmentId}/deliveryWindowOptions", configuration.base_path, inboundPlanId=crate::apis::urlencode(p_inbound_plan_id), shipmentId=crate::apis::urlencode(p_shipment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("pageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_pagination_token {
        req_builder = req_builder.query(&[("paginationToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ListDeliveryWindowOptionsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ListDeliveryWindowOptionsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListDeliveryWindowOptionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Provides a paginated list of box packages in an inbound plan.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 6 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn list_inbound_plan_boxes(configuration: &configuration::Configuration, inbound_plan_id: &str, page_size: Option<i32>, pagination_token: Option<&str>) -> Result<models::fulfillment_inbound_2024_03_20::ListInboundPlanBoxesResponse, Error<ListInboundPlanBoxesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inbound_plan_id = inbound_plan_id;
    let p_page_size = page_size;
    let p_pagination_token = pagination_token;

    let uri_str = format!("{}/inbound/fba/2024-03-20/inboundPlans/{inboundPlanId}/boxes", configuration.base_path, inboundPlanId=crate::apis::urlencode(p_inbound_plan_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("pageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_pagination_token {
        req_builder = req_builder.query(&[("paginationToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ListInboundPlanBoxesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ListInboundPlanBoxesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListInboundPlanBoxesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Provides a paginated list of item packages in an inbound plan.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 6 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn list_inbound_plan_items(configuration: &configuration::Configuration, inbound_plan_id: &str, page_size: Option<i32>, pagination_token: Option<&str>) -> Result<models::fulfillment_inbound_2024_03_20::ListInboundPlanItemsResponse, Error<ListInboundPlanItemsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inbound_plan_id = inbound_plan_id;
    let p_page_size = page_size;
    let p_pagination_token = pagination_token;

    let uri_str = format!("{}/inbound/fba/2024-03-20/inboundPlans/{inboundPlanId}/items", configuration.base_path, inboundPlanId=crate::apis::urlencode(p_inbound_plan_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("pageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_pagination_token {
        req_builder = req_builder.query(&[("paginationToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ListInboundPlanItemsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ListInboundPlanItemsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListInboundPlanItemsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Provides a paginated list of pallet packages in an inbound plan. An inbound plan will have pallets when the related details are provided after generating Less-Than-Truckload (LTL) carrier shipments.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 6 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn list_inbound_plan_pallets(configuration: &configuration::Configuration, inbound_plan_id: &str, page_size: Option<i32>, pagination_token: Option<&str>) -> Result<models::fulfillment_inbound_2024_03_20::ListInboundPlanPalletsResponse, Error<ListInboundPlanPalletsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inbound_plan_id = inbound_plan_id;
    let p_page_size = page_size;
    let p_pagination_token = pagination_token;

    let uri_str = format!("{}/inbound/fba/2024-03-20/inboundPlans/{inboundPlanId}/pallets", configuration.base_path, inboundPlanId=crate::apis::urlencode(p_inbound_plan_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("pageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_pagination_token {
        req_builder = req_builder.query(&[("paginationToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ListInboundPlanPalletsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ListInboundPlanPalletsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListInboundPlanPalletsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Provides a list of inbound plans with minimal information.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 6 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn list_inbound_plans(configuration: &configuration::Configuration, page_size: Option<i32>, pagination_token: Option<&str>, status: Option<&str>, sort_by: Option<&str>, sort_order: Option<&str>) -> Result<models::fulfillment_inbound_2024_03_20::ListInboundPlansResponse, Error<ListInboundPlansError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_page_size = page_size;
    let p_pagination_token = pagination_token;
    let p_status = status;
    let p_sort_by = sort_by;
    let p_sort_order = sort_order;

    let uri_str = format!("{}/inbound/fba/2024-03-20/inboundPlans", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("pageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_pagination_token {
        req_builder = req_builder.query(&[("paginationToken", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_status {
        req_builder = req_builder.query(&[("status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_by {
        req_builder = req_builder.query(&[("sortBy", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_order {
        req_builder = req_builder.query(&[("sortOrder", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ListInboundPlansResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ListInboundPlansResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListInboundPlansError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List the inbound compliance details for MSKUs in a given marketplace.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 6 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn list_item_compliance_details(configuration: &configuration::Configuration, mskus: Vec<String>, marketplace_id: &str) -> Result<models::fulfillment_inbound_2024_03_20::ListItemComplianceDetailsResponse, Error<ListItemComplianceDetailsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_mskus = mskus;
    let p_marketplace_id = marketplace_id;

    let uri_str = format!("{}/inbound/fba/2024-03-20/items/compliance", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = match "multi" {
        "multi" => req_builder.query(&p_mskus.into_iter().map(|p| ("mskus".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("mskus", &p_mskus.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    req_builder = req_builder.query(&[("marketplaceId", &p_marketplace_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ListItemComplianceDetailsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ListItemComplianceDetailsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListItemComplianceDetailsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves a page of boxes from a given packing group. These boxes were previously provided through the `setPackingInformation` operation. This API is used for workflows where boxes are packed before Amazon determines shipment splits.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 30 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn list_packing_group_boxes(configuration: &configuration::Configuration, inbound_plan_id: &str, packing_group_id: &str, page_size: Option<i32>, pagination_token: Option<&str>) -> Result<models::fulfillment_inbound_2024_03_20::ListPackingGroupBoxesResponse, Error<ListPackingGroupBoxesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inbound_plan_id = inbound_plan_id;
    let p_packing_group_id = packing_group_id;
    let p_page_size = page_size;
    let p_pagination_token = pagination_token;

    let uri_str = format!("{}/inbound/fba/2024-03-20/inboundPlans/{inboundPlanId}/packingGroups/{packingGroupId}/boxes", configuration.base_path, inboundPlanId=crate::apis::urlencode(p_inbound_plan_id), packingGroupId=crate::apis::urlencode(p_packing_group_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("pageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_pagination_token {
        req_builder = req_builder.query(&[("paginationToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ListPackingGroupBoxesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ListPackingGroupBoxesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListPackingGroupBoxesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves a page of items in a given packing group. Packing options must first be generated by the corresponding operation before packing group items can be listed.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 30 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn list_packing_group_items(configuration: &configuration::Configuration, inbound_plan_id: &str, packing_group_id: &str, page_size: Option<i32>, pagination_token: Option<&str>) -> Result<models::fulfillment_inbound_2024_03_20::ListPackingGroupItemsResponse, Error<ListPackingGroupItemsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inbound_plan_id = inbound_plan_id;
    let p_packing_group_id = packing_group_id;
    let p_page_size = page_size;
    let p_pagination_token = pagination_token;

    let uri_str = format!("{}/inbound/fba/2024-03-20/inboundPlans/{inboundPlanId}/packingGroups/{packingGroupId}/items", configuration.base_path, inboundPlanId=crate::apis::urlencode(p_inbound_plan_id), packingGroupId=crate::apis::urlencode(p_packing_group_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("pageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_pagination_token {
        req_builder = req_builder.query(&[("paginationToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ListPackingGroupItemsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ListPackingGroupItemsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListPackingGroupItemsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves a list of all packing options for an inbound plan. Packing options must first be generated by the corresponding operation before becoming available.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 6 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn list_packing_options(configuration: &configuration::Configuration, inbound_plan_id: &str, page_size: Option<i32>, pagination_token: Option<&str>) -> Result<models::fulfillment_inbound_2024_03_20::ListPackingOptionsResponse, Error<ListPackingOptionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inbound_plan_id = inbound_plan_id;
    let p_page_size = page_size;
    let p_pagination_token = pagination_token;

    let uri_str = format!("{}/inbound/fba/2024-03-20/inboundPlans/{inboundPlanId}/packingOptions", configuration.base_path, inboundPlanId=crate::apis::urlencode(p_inbound_plan_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("pageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_pagination_token {
        req_builder = req_builder.query(&[("paginationToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ListPackingOptionsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ListPackingOptionsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListPackingOptionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Provides a list of all placement options for an inbound plan. Placement options must first be generated by the corresponding operation before becoming available.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 6 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn list_placement_options(configuration: &configuration::Configuration, inbound_plan_id: &str, page_size: Option<i32>, pagination_token: Option<&str>) -> Result<models::fulfillment_inbound_2024_03_20::ListPlacementOptionsResponse, Error<ListPlacementOptionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inbound_plan_id = inbound_plan_id;
    let p_page_size = page_size;
    let p_pagination_token = pagination_token;

    let uri_str = format!("{}/inbound/fba/2024-03-20/inboundPlans/{inboundPlanId}/placementOptions", configuration.base_path, inboundPlanId=crate::apis::urlencode(p_inbound_plan_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("pageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_pagination_token {
        req_builder = req_builder.query(&[("paginationToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ListPlacementOptionsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ListPlacementOptionsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListPlacementOptionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get preparation details for a list of MSKUs in a specified marketplace.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 30 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn list_prep_details(configuration: &configuration::Configuration, marketplace_id: &str, mskus: Vec<String>) -> Result<models::fulfillment_inbound_2024_03_20::ListPrepDetailsResponse, Error<ListPrepDetailsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_marketplace_id = marketplace_id;
    let p_mskus = mskus;

    let uri_str = format!("{}/inbound/fba/2024-03-20/items/prepDetails", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("marketplaceId", &p_marketplace_id.to_string())]);
    req_builder = match "multi" {
        "multi" => req_builder.query(&p_mskus.into_iter().map(|p| ("mskus".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("mskus", &p_mskus.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ListPrepDetailsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ListPrepDetailsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListPrepDetailsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Provides a paginated list of box packages in a shipment.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 30 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn list_shipment_boxes(configuration: &configuration::Configuration, inbound_plan_id: &str, shipment_id: &str, page_size: Option<i32>, pagination_token: Option<&str>) -> Result<models::fulfillment_inbound_2024_03_20::ListShipmentBoxesResponse, Error<ListShipmentBoxesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inbound_plan_id = inbound_plan_id;
    let p_shipment_id = shipment_id;
    let p_page_size = page_size;
    let p_pagination_token = pagination_token;

    let uri_str = format!("{}/inbound/fba/2024-03-20/inboundPlans/{inboundPlanId}/shipments/{shipmentId}/boxes", configuration.base_path, inboundPlanId=crate::apis::urlencode(p_inbound_plan_id), shipmentId=crate::apis::urlencode(p_shipment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("pageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_pagination_token {
        req_builder = req_builder.query(&[("paginationToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ListShipmentBoxesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ListShipmentBoxesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListShipmentBoxesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve a paginated list of shipment content update previews for a given shipment. The shipment content update preview is a summary of the requested shipment content changes along with the transportation cost implications of the change that can only be confirmed prior to the expiry date specified.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 30 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn list_shipment_content_update_previews(configuration: &configuration::Configuration, inbound_plan_id: &str, shipment_id: &str, page_size: Option<i32>, pagination_token: Option<&str>) -> Result<models::fulfillment_inbound_2024_03_20::ListShipmentContentUpdatePreviewsResponse, Error<ListShipmentContentUpdatePreviewsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inbound_plan_id = inbound_plan_id;
    let p_shipment_id = shipment_id;
    let p_page_size = page_size;
    let p_pagination_token = pagination_token;

    let uri_str = format!("{}/inbound/fba/2024-03-20/inboundPlans/{inboundPlanId}/shipments/{shipmentId}/contentUpdatePreviews", configuration.base_path, inboundPlanId=crate::apis::urlencode(p_inbound_plan_id), shipmentId=crate::apis::urlencode(p_shipment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("pageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_pagination_token {
        req_builder = req_builder.query(&[("paginationToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ListShipmentContentUpdatePreviewsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ListShipmentContentUpdatePreviewsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListShipmentContentUpdatePreviewsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Provides a paginated list of item packages in a shipment.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 30 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn list_shipment_items(configuration: &configuration::Configuration, inbound_plan_id: &str, shipment_id: &str, page_size: Option<i32>, pagination_token: Option<&str>) -> Result<models::fulfillment_inbound_2024_03_20::ListShipmentItemsResponse, Error<ListShipmentItemsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inbound_plan_id = inbound_plan_id;
    let p_shipment_id = shipment_id;
    let p_page_size = page_size;
    let p_pagination_token = pagination_token;

    let uri_str = format!("{}/inbound/fba/2024-03-20/inboundPlans/{inboundPlanId}/shipments/{shipmentId}/items", configuration.base_path, inboundPlanId=crate::apis::urlencode(p_inbound_plan_id), shipmentId=crate::apis::urlencode(p_shipment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("pageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_pagination_token {
        req_builder = req_builder.query(&[("paginationToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ListShipmentItemsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ListShipmentItemsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListShipmentItemsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Provides a paginated list of pallet packages in a shipment. A palletized shipment will have pallets when the related details are provided after generating Less-Than-Truckload (LTL) carrier shipments.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 30 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn list_shipment_pallets(configuration: &configuration::Configuration, inbound_plan_id: &str, shipment_id: &str, page_size: Option<i32>, pagination_token: Option<&str>) -> Result<models::fulfillment_inbound_2024_03_20::ListShipmentPalletsResponse, Error<ListShipmentPalletsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inbound_plan_id = inbound_plan_id;
    let p_shipment_id = shipment_id;
    let p_page_size = page_size;
    let p_pagination_token = pagination_token;

    let uri_str = format!("{}/inbound/fba/2024-03-20/inboundPlans/{inboundPlanId}/shipments/{shipmentId}/pallets", configuration.base_path, inboundPlanId=crate::apis::urlencode(p_inbound_plan_id), shipmentId=crate::apis::urlencode(p_shipment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("pageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_pagination_token {
        req_builder = req_builder.query(&[("paginationToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ListShipmentPalletsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ListShipmentPalletsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListShipmentPalletsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves all transportation options for a shipment. Transportation options must first be generated by the `generateTransportationOptions` operation before becoming available.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 6 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn list_transportation_options(configuration: &configuration::Configuration, inbound_plan_id: &str, page_size: Option<i32>, pagination_token: Option<&str>, placement_option_id: Option<&str>, shipment_id: Option<&str>) -> Result<models::fulfillment_inbound_2024_03_20::ListTransportationOptionsResponse, Error<ListTransportationOptionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inbound_plan_id = inbound_plan_id;
    let p_page_size = page_size;
    let p_pagination_token = pagination_token;
    let p_placement_option_id = placement_option_id;
    let p_shipment_id = shipment_id;

    let uri_str = format!("{}/inbound/fba/2024-03-20/inboundPlans/{inboundPlanId}/transportationOptions", configuration.base_path, inboundPlanId=crate::apis::urlencode(p_inbound_plan_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("pageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_pagination_token {
        req_builder = req_builder.query(&[("paginationToken", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_placement_option_id {
        req_builder = req_builder.query(&[("placementOptionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_shipment_id {
        req_builder = req_builder.query(&[("shipmentId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ListTransportationOptionsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ListTransportationOptionsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListTransportationOptionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Confirms or reschedules a self-ship appointment slot against a shipment. Only available in the following [marketplaces](https://developer-docs.amazon.com/sp-api/docs/marketplace-ids): MX, BR, EG, SA, AE, IN.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 2 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api). 
pub async fn schedule_self_ship_appointment(configuration: &configuration::Configuration, inbound_plan_id: &str, shipment_id: &str, slot_id: &str, body: models::fulfillment_inbound_2024_03_20::ScheduleSelfShipAppointmentRequest) -> Result<models::fulfillment_inbound_2024_03_20::ScheduleSelfShipAppointmentResponse, Error<ScheduleSelfShipAppointmentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inbound_plan_id = inbound_plan_id;
    let p_shipment_id = shipment_id;
    let p_slot_id = slot_id;
    let p_body = body;

    let uri_str = format!("{}/inbound/fba/2024-03-20/inboundPlans/{inboundPlanId}/shipments/{shipmentId}/selfShipAppointmentSlots/{slotId}/schedule", configuration.base_path, inboundPlanId=crate::apis::urlencode(p_inbound_plan_id), shipmentId=crate::apis::urlencode(p_shipment_id), slotId=crate::apis::urlencode(p_slot_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ScheduleSelfShipAppointmentResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::ScheduleSelfShipAppointmentResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ScheduleSelfShipAppointmentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sets packing information for an inbound plan. This should be called after an inbound plan is created to populate the box level information required for planning and transportation estimates.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 2 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn set_packing_information(configuration: &configuration::Configuration, inbound_plan_id: &str, body: models::fulfillment_inbound_2024_03_20::SetPackingInformationRequest) -> Result<models::fulfillment_inbound_2024_03_20::SetPackingInformationResponse, Error<SetPackingInformationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inbound_plan_id = inbound_plan_id;
    let p_body = body;

    let uri_str = format!("{}/inbound/fba/2024-03-20/inboundPlans/{inboundPlanId}/packingInformation", configuration.base_path, inboundPlanId=crate::apis::urlencode(p_inbound_plan_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::SetPackingInformationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::SetPackingInformationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SetPackingInformationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Set the preparation details for a list of MSKUs in a specified marketplace.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 30 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn set_prep_details(configuration: &configuration::Configuration, body: models::fulfillment_inbound_2024_03_20::SetPrepDetailsRequest) -> Result<models::fulfillment_inbound_2024_03_20::SetPrepDetailsResponse, Error<SetPrepDetailsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body = body;

    let uri_str = format!("{}/inbound/fba/2024-03-20/items/prepDetails", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::SetPrepDetailsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::SetPrepDetailsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SetPrepDetailsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the name of an existing inbound plan.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 30 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn update_inbound_plan_name(configuration: &configuration::Configuration, inbound_plan_id: &str, body: models::fulfillment_inbound_2024_03_20::UpdateInboundPlanNameRequest) -> Result<(), Error<UpdateInboundPlanNameError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inbound_plan_id = inbound_plan_id;
    let p_body = body;

    let uri_str = format!("{}/inbound/fba/2024-03-20/inboundPlans/{inboundPlanId}/name", configuration.base_path, inboundPlanId=crate::apis::urlencode(p_inbound_plan_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateInboundPlanNameError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update compliance details for a list of MSKUs. The details provided here are only used for the India (IN - A21TJRUUN4KGV) marketplace compliance validation.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 6 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn update_item_compliance_details(configuration: &configuration::Configuration, marketplace_id: &str, body: models::fulfillment_inbound_2024_03_20::UpdateItemComplianceDetailsRequest) -> Result<models::fulfillment_inbound_2024_03_20::UpdateItemComplianceDetailsResponse, Error<UpdateItemComplianceDetailsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_marketplace_id = marketplace_id;
    let p_body = body;

    let uri_str = format!("{}/inbound/fba/2024-03-20/items/compliance", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    req_builder = req_builder.query(&[("marketplaceId", &p_marketplace_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::UpdateItemComplianceDetailsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::UpdateItemComplianceDetailsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateItemComplianceDetailsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the name of an existing shipment.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 30 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn update_shipment_name(configuration: &configuration::Configuration, inbound_plan_id: &str, shipment_id: &str, body: models::fulfillment_inbound_2024_03_20::UpdateShipmentNameRequest) -> Result<(), Error<UpdateShipmentNameError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inbound_plan_id = inbound_plan_id;
    let p_shipment_id = shipment_id;
    let p_body = body;

    let uri_str = format!("{}/inbound/fba/2024-03-20/inboundPlans/{inboundPlanId}/shipments/{shipmentId}/name", configuration.base_path, inboundPlanId=crate::apis::urlencode(p_inbound_plan_id), shipmentId=crate::apis::urlencode(p_shipment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateShipmentNameError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the source address of an existing shipment. The shipment source address can only be updated prior to the confirmation of the shipment carriers. As a result of the updated source address, existing transportation options will be invalidated and will need to be regenerated to capture the potential difference in transportation options and quotes due to the new source address.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 30 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn update_shipment_source_address(configuration: &configuration::Configuration, inbound_plan_id: &str, shipment_id: &str, body: models::fulfillment_inbound_2024_03_20::UpdateShipmentSourceAddressRequest) -> Result<models::fulfillment_inbound_2024_03_20::UpdateShipmentSourceAddressResponse, Error<UpdateShipmentSourceAddressError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inbound_plan_id = inbound_plan_id;
    let p_shipment_id = shipment_id;
    let p_body = body;

    let uri_str = format!("{}/inbound/fba/2024-03-20/inboundPlans/{inboundPlanId}/shipments/{shipmentId}/sourceAddress", configuration.base_path, inboundPlanId=crate::apis::urlencode(p_inbound_plan_id), shipmentId=crate::apis::urlencode(p_shipment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::UpdateShipmentSourceAddressResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::UpdateShipmentSourceAddressResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateShipmentSourceAddressError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates a shipment's tracking details.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 2 | 2 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The preceding table contains the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may have higher rate and burst values than those shown here. For more information, refer to [Usage Plans and Rate Limits in the Selling Partner API](https://developer-docs.amazon.com/sp-api/docs/usage-plans-and-rate-limits-in-the-sp-api).
pub async fn update_shipment_tracking_details(configuration: &configuration::Configuration, inbound_plan_id: &str, shipment_id: &str, body: models::fulfillment_inbound_2024_03_20::UpdateShipmentTrackingDetailsRequest) -> Result<models::fulfillment_inbound_2024_03_20::UpdateShipmentTrackingDetailsResponse, Error<UpdateShipmentTrackingDetailsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_inbound_plan_id = inbound_plan_id;
    let p_shipment_id = shipment_id;
    let p_body = body;

    let uri_str = format!("{}/inbound/fba/2024-03-20/inboundPlans/{inboundPlanId}/shipments/{shipmentId}/trackingDetails", configuration.base_path, inboundPlanId=crate::apis::urlencode(p_inbound_plan_id), shipmentId=crate::apis::urlencode(p_shipment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::UpdateShipmentTrackingDetailsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::fulfillment_inbound_2024_03_20::UpdateShipmentTrackingDetailsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateShipmentTrackingDetailsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

